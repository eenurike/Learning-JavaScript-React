'use strict';

// Функции это наши действия в JS, они используют различные типы данных и изменяют информацию так как мы ей укажем, так же это значительно сокращает наш код прямо как циклы. Можно функцию представить как калькулятор, нам нет нужды каждый раз вводить какие-то математические вычисления, мы просто вводим числа и калькулятор делает все за нас, сама эта структура это просто набор функций сложение/вычитание/деление/умножение, если открыть инженерный калькулятор, то там намного больше будет функций. Тоже самое можно сказать про микровалновку, холодильник у всех них есть какие-то функции, которые они выполняют

function showFirstMessage() {
  // Имя функции может быть любым, но только осмысленным, имя должно быть глаголом с припиской того над чем выполняется действие. В круглые скобки будем передавать аргументы функции
  console.log('Hello World!');
}
// Сейчас функция просто существует в коде, она никак не выполняется, она просто есть, для того чтобы она заработала, ее нужно вызвать
showFirstMessage(); // Hello World!

// Есть и функции анонимные, то есть без имени. Они вызываются и используются здесь и сейчас только один раз, поэтому впринципе им имя давать и не нужно. Анонимные функции разберем дальше

// У функции есть так же и аргументы, которые записываем в круглые скобки. Когда функция вызывается, мы можем ей дать какие-то данные которые она будет использовать внутри себя. Опять напримере калькулятора, мы как функцию передаем два аргумента, нажимаем 4, затем +, затем 6 и нажимаем =, и калькулятор показывает результат 10. Это мы передали два аргумента 4 и 6 в функцию сложения

function showFirstMessage2(text) {
  console.log(text);
}

showFirstMessage2('Hello World!');
// Когда функция запустится, она возмет эту строку Hello World! которую мы ей передали, подставит ее вместо аргумента функции, и потом засунет в console.log

// Если вдаваться в детали, то аргументов на самом деле может быть бесконечное кол-во showFirstMessage(text, arg, num, и т.д.). Чуть позже познакомимся с одной фишкой нового стандарта, для того чтобы быстро указать что этих аргументов у нас может быть много, но на баззовом уровне такой REST оператор пока не нужен

//Как ведут себя переменные в функциях

function showSecondMessage(text) {
  console.log(text);
  let num = 20;

}

showSecondMessage('Hello World!');
console.log(num);
// num is not defined. Когда мы обьяевляем переменную внутри функции, то снаружи она уже не доступна. Такие переменными называются локальными, она существует только внутри функции

let num2 = 20;
// Так мы обьявили глобальную переменную

function showSecondMessage(text) {
  console.log(text);
  num2 = 30;
  // А здесь мы уже ее переиспользовали, и это значит что лубая фукнция, она может спокойно брать и использовать глобальную переменную внутри себя
}

showSecondMessage('Hello Nurike!');
console.log(num2);
// 30, Потомучто мы в функции переназначили переменную

let num3 = 20;

function showSecondMessage(text) {
  console.log(text);
  let num3 = 10;

}
// Это две разных переменных

showSecondMessage('Hello Nurike!');
console.log(num3);
// 20, он видит глобальную переменную, а локальная скрыта

// Замыкание функций - это сама функция вместе со всеми внешними переменными которыми ей доступны

let num4 = 20;

function showSecondMessage(text) {
  console.log(text);
  let num4 = 10;
  console.log(num4);  // 10
}
// Эта переменная num4 которая внутри функции, когда код доходит до console.log(num4), она сперва начинает искать эту переменную внутри функции, находит и выводит ее

showSecondMessage('Hello Nurike!');
console.log(num4);

let num5 = 20;

function showSecondMessage(text) {
  console.log(text);
  console.log(num5); // 20
}
// Но если в функции нет переменной num5, функция начинает искать на уровень выше, находит глобальную переменную num5, и выводит уже ее

showSecondMessage('Hello Nurike!');
console.log(num5);  // 20

// Функция так же может вернуть нам какое либо значение, при помощи ключевого слово return, как только функция увидит return она прекратит свое действие. return позволяет нам вернуть какое либо значение во внешний мир

function calc(a, b) {
  // let plus = a + b;
  // return plus; ИЛИ
  return (a + b);
  // Можно и без скобок, скобки для того чтоб просто сгрупировать это значение
}
// Когда запустится функция calc она нам вернет сумму первого арнумента и второго, и эта маленькая функция уже решает за нас очень многие проблемы, так как мы ее можем переиспользовать много раз

console.log(calc(5, 6));  // 11
console.log(calc(2, 40)); // 42
console.log(calc(1, 2));  // 33
console.log(calc(9, 1));  // 10
// И теперь просто переиспользуем эту функцию с разными аргументами, в этом и заключается суть функций, автоматизация наших процессов.

function calc(a, b) {
  return (a + b);
  //console.log(num2);
  // Unreachable, не читаемый код, так как после return, дальше идет мертвый код. return это окончание функции
}

// Но у return есть еще одно применение, не только окончание функции, но и возвращение значения наружу
function ret() {
  let num = 20;
  return num;
  // То-есть во внешний мир наша функция возвращает значение своей локальной переменной, этот прием в практике очень часто используется, ведь в функции может выполнятся какой-то огромный код, какая-то логика по работе с зарплатами, с какими-то данными и прочим, и вконце нам возвращается результат работы это функции, и его мы уже можем куда-то записать
}

console.log(ret()); // 20
const anotherNum = ret();
console.log(anotherNum);  // 20

// Классификация функций
// 1) Function Declaration - это по факту функции которые мы уже использовали, и у нее есть одна очень важная особенность, она существует еще до того как наш код запустится, как переменная var. Работает это так наша html страница она загружается, у нее все идет по порядку, потом доходит до скрипта дело, скрипт начинает загружаться, первым делом браузер пробигается по скрипту, и находит все переменные var если они есть и все function declaration. Он их создает, он их обьявляет, и после этого наш код начинает выполнятся. И какое приемущество у этого подхода есть, если функция существует до того как она была обьевлена
console.log(testFun('nurike', ' is a great Frontend Developer'));

function testFun(a, b) {
  return a + b;
}
// Иногда разработчики такой прием применяют, что все функции которые созданы в одном из файлов, они помещают их в самый низ страницы, а сверху просто используют, ну это уже стилистика у каждого разработчика будет своя

// 2) Function Expression - функциональное выражение, тут синтаксис немного отличается, мы должны создать переменную и во внутрь положить какую-то функцию
const logger = function() {
  console.log('Hello');
};

logger();
// Такая функция создается только тогда, когда до нее дохожит поток кода и ее можно вызвать только после ее обьвления
// logger();

// const logger = function() {
//   console.log('Hello');
// };
// Так уже мы сделать не можем, выдаст ошибку

// 3) Стрелочная функция, был добавлен в стандарте ES6
// const calc2 = (a, b) => a + b; это сокращенный вариант, если функция только в одну строку, то можно опускать фигурные скобки, и такой способ очень часто будем встречат, более того если один аргумент, можно записать и так
// const calc2 = a => a + b;
const calc2 = (a, b) => {
  console.log('This is function');
  return a + b;
};
// Понятное дело такой синтаксис очень сильно позволяет сократить код, однако перед тем как ее использовать нужно знать ее особенности. Такая функция не имеет контекста вызова, поэтому ее часто можно встретить в обработчиках события, ну эти темы дальнейших уроков. Пока что помни у нее есть свои особенности и везде прям ее использовать нельзя, хотя очень хотелось бы

// Еще раз про аргументы функции и почему это важно
// Конечно любые операции в коде мы можем записать в потоке кода, но они выполняются только один раз, когда код дойдет до них. Если же это действие мы хотим повторить несколько раз в будущем, то и него стоит создавать функцию, например функция перещета курса валют, пользователь вводит разные значения, а у нас должна быть функция которая каждый раз будет пересчитывать результат. Нужно знать что функция каждый раз получает новое значение для пересчета

function convert(amount) {
  console.log(28 * amount);
  // Допустим 28 сегоднейший курс
}

convert(500); // Допустим хотим конвертировать 500 по курсу 28
// Очень важная деталь, функция изначально незнает какое значение введет ему пользователь, точно так же как и на сайте, это очень важно так как значение подставляется только во время вызова этой функции, а в самом значении она определяется как аргумент. И вообще можем сделать так что и курс валют наша функция не будет знать, эти данные будут приходить к нам от банка

