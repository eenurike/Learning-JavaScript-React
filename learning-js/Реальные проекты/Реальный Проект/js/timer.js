'use strict';

window.addEventListener('DOMContentLoaded', () => {

    let tabs = document.querySelectorAll('.tabheader__item'),   
        tabsContent = document.querySelectorAll('.tabcontent'), 
        tabsParent = document.querySelector('.tabheader__items');   


    function hideTabContent() {
       tabsContent.forEach(item => {
        item.classList.add('hide');
        item.classList.remove('show', 'fade');
       });

        tabs.forEach(item => {
            item.classList.remove('tabheader__item_active');
        });
    }

    function showTabContent(i = 0) {   
        tabsContent[i].classList.add('show', 'fade');
        tabsContent[i].classList.remove('hide');
        
        tabs[i].classList.add('tabheader__item_active');
    }

    hideTabContent();
    showTabContent();

    tabsParent.addEventListener('click', (event) => {
        const target = event.target;

        if (target && target.classList.contains('tabheader__item')) {
           tabs.forEach((item,i) => {

                if (target == item) {
                    hideTabContent();
                    showTabContent(i);
                }
           });
        }
    });

    // Создаем таймер 
    /*
    1) Функция которая будет устанавливать таймер, получать элементы 
    таймера и что то с ними делать 
    2) Функция которая будет определять разницу между временем, конечно
    у нас будет какой то дед лайн, сколько осталось до конца акции. 
    Это будем устанавливать в формате даты. И на этом этапе необходимо 
    будет вычислить время, которое сейчас установленно у пользователя и 
    найти эту разницу, которую будем отображать на экране
    3) Функция которая будет заниматься обновлением таймера, то есть 
    тикать время в живую 

    На сайтах есть не сколько типов таймров, есть честные таймеры, которые
    четко отсчитывают время до определенного, а есть те которые работают на
    продажу (то есть они зарускаются когда вы заходите на страницу, запоминают
    вас как пользователя, и ориентируясь только на пользователя отчитывают время)
    */
   
    const deadline = '2021-05-13';  // Это будет наша конечная точка
    /*
    В эту переменную, дата может прилететь с type=input или с сервера.
    Создадим функцию которая будет определять разницу между
    дед лайном и текущем временем 
    */
    function getTimeRemaining(endtime) {
    /*
    Так как input нам возвращает дату в таком виде '2021-05-12'
    от такой строки мы не можем отнять какоето кол-во миллисекунд,
    математические операции тут не возможны, и эту строку нам надо
    перевести во чтото осезаемое 
    */
        const t = Date.parse(endtime) - Date.parse(new Date());
    /*
    Тут мы наш дед лайн и текущее время перевели в формат миллисекунд. 
    Отнимаем конечную дату от текущей даты и получим сколько времени осталось.
    Затем эти миллисекунды нужно превратить в кол-во дней, часов, минут, секунд
    */ 
        const days = Math.floor( (t/(1000*60*60*24)) );
    /*
    Округлим наше значение засчет Math.floor, так как результат можем получить
    в дробных значениях, дальше нашу разницу в миллисекундах делим на произведение
    1000 милисекунд * 60 так получаем кол-во миллисекунд в одной минуте * 60 получаем
    миллисекунды в часе * 24 и получаем сколько миллисекунд в сутках. Так мы получаем
    сколько дней осталось до нашего дед лайна
    */
        const hours = Math.floor( (t/(1000*60*60) % 24) );
    /*
    (t / (1000 * 60 * 60)) так мы получим общее кол-во часов до окончания дед лайна,
    а нам ведь надо часы получать в формате 24 часа и не больше 
    (t / (1000 * 60 * 60) % 24) так мы получим именно остаток часов до полных суток,
    наше кол-во миллисекунд делим на 24, и именно осаток на возвращается,
    например у нас 50 часов до оканчании акции, 50 / 24 два дня это 48 часов и остается 2 часа
    */
        const minutes = Math.floor( (t / 1000 / 60) % 60);
    /*
    ((t / 1000 / 60) % 60) делим общее кол-во миллисекуд на секундыminutes = Math.floor( (t/1000/60) % 60 ), получаем 
    сколько секунд осталось, эти секунды делим на минуты, и эти минуты делим 
    на 60(потому что в минуте 60 секунд) и получаем остаток
    */
        const seconds = Math.floor( (t/1000) % 60 );
    /*
    В остатке получили кол-во секунд 
    */
        
    /*
    Сейчас эти переменные у нас находятся в функции, и нам нужен доступ к ним
    вне этой функции
    */
    return {
        'total': t,
        'days': days,
        'hours': hours,
        'minutes': minutes,
        'seconds': seconds
    };
   /*
   Такой прием часто используется если много переменных которых нужно
   возвратить, помещаем их всех в обьект
   */
   }



    /*
    Эта функция на тот случай если клиент хочет чтоб отображалось 01,02 - 09
    */
    function getZero(num) {
        if (num >= 0 && num < 10) {
            return `0${num}`;
        } else {
            return num;
        }
    }


    

    /* Функция установки таймера */
    function setClock(selector, endtime) {
        const timer = document.querySelector(selector),
            /*
            Передали аргумент прям в querySelector, так как можно будет создать
            разные таймеры на странице
            */
              days = timer.querySelector('#days'),        
              hours = timer.querySelector('#hours'),        
              minutes = timer.querySelector('#minutes'),        
              seconds = timer.querySelector('#seconds'),
              /* И нам ведь нужно запускать функцию каждую секунду, чтоб часы тикали */
              timeInterval = setInterval(updateClock, 1000);  
              
              updateClock();
              /*
              Запускаем функцию upedateClock, чтоб не было мигание таймер при перезагрузки страницы.
              Ведь у нас в верстке стаит заглушка часов, а наш setInterval запустится только через секунду,
              поэтому секунды мы видим заглушку со страницы  
              */

        /*
        Функция которая будет обновлять таймер каждую секунду
        */
        function updateClock() {
            /*
            Расчет времени который остался
            */
            let t = getTimeRemaining(endtime);
            /*
            Вот почему создали функцию внутри, потому что при вызове функции
            setClock туда передастся аргумент endtime, и этот аргумент пойдет 
            в переменную t, а getTimeRemaining возвращает нам разницу во времени
            */

        //days.innerHTML = t.days;

           /*
           days это переменная куда поместили элемент со страницы, а не посредственно
           туда через innerHTML запихиваем структуру html, можно вместо innerHTML
           записать textContent. А t.days - t это переменная куда поместили обьект
           с возвращенными значениями, days это свойство обьекта, или записали бы 
           вот так t['days']
           */

        //hours.innerHTML = t.hours;
        //minutes.innerHTML = t.minutes;
        //seconds.innerHTML = t.seconds;



            /*
            На тот случай если клиент потребует чтоб цифры отображались так 01,02 - 09,
            если не надо то верхний используем закоментировать этот код, и разкоментитровать
            верхний код
            */
            days.innerHTML = getZero(t.days);
            hours.innerHTML = getZero(t.hours);
            minutes.innerHTML = getZero(t.minutes);
            seconds.innerHTML = getZero(t.seconds);




           /*
           Когда запустится updateClock, он расчитает нам время, и на основании
           этих расчетов поместить их на страницу.
           Ну и нам нужно остановить таймер когда время истечет 
           */
           if (t.total <= 0) {
               clearInterval(timeInterval);
               /*
               Если милисекунды переселки отметку через 0, то останавливаем таймер 
               */
           }
          
        }
    }

    setClock('.timer', deadline);
});


