// Контекст вызова

// 'use strict';

/* this это то что окружает функцию и в каких условиях оно вызывается.
Для примера, представь человека без определенного места жительства,
и получается что этот человек функционирует в пределах всего мира,
у него нет привязки к конкретному месту, но если мы его поместим
в специальное учреждение, где он сможет жить и чем то заниматься,
то он уже получит так называемый контекст вызова, теперь у него есть
свое место для функционирования.
Функция может вызываться 4-мя способами, и в каждом контекст вызова
отличается */

/* 1 метод. Это просто вызов нашей функции 
но чтоб увидить этот метод, нужно закоментировать use strict,
и посмотреть эту функцию через браузер */

function showThis() {
    console.log(this);
}
showThis();

/* И видим глобальный обьект window, отсюда делаем вывод.
Если функция просто запускается, вот таким образом,
и когда используем в ней контекст, то этот контекст будет 
ссылаться на глобальный обьект window, это правило верно для
обычного кода, без строго режима, а если запустим такую функцию
со строгим режимом use strict, то jshint сразу начнет ругаться,
и вернет нам undefined. Это первый и самый частый способ
вызова функции, и теперь знаем чему равен this внутри 
такого вызова 
1) Обычная функция: this = window, но если use strict = undefined!!! */

function testThis(a,b) {
    console.log(this);
    function sum() {
        console.log(this);
        /* И в таких задачках часто пишут this.a */
        return this.a + this.b;
    }
    console.log(sum());
}
testThis(5,6);

/* Тут два главных вопроса: 
1) Что выведет в sum console.log(this) какой контеткс вызова у функции sum
2) Будет ли работать этот return и если нет то как его исправить.
1) - Получаем два undefined, вывод такой не важно где функция sum запускается,
главное что у нее контекст вызова будет такой же window или с use strict undefined,
даже если у нас используется функция внутри функции контекст у нее не меняется 
2) - a и b is not defined, короче не видит эти значения, 
испраляем чтоб наша сумма работала, тут достаточно использовать замыкание функции 
function sum() {
        console.log(this);

        return a + b;
    }
    да этих аргументов у sum нет, но засчет того что у нас есть замыкание функции,
    когда запускается sum, она a и b ищет сперва внутри себя она их не находит,
    и она обращается уже к родительской функции testThis, и sum имеет доступ к 
    аргументам a и b у testThis, и которые мы передадим testThis(5,6)
*/

/* 2 метод. Помним что методы обьектов это тоже функции */

const obj = {
    a: 20,
    b: 15,
    sum: function() {
        console.log(this);
    }
};
obj.sum();
/* Получили тот обьект, в котором находится этот метод.
Если мы используем метод внутри обьекта, то контектс вызова
будет ссылаться на этот обьект
2) Контекст у методов обьекта = самому обьекту!!! */

const obj2 = {
    a: 22,
    b: 13,
    sum2: function() {
        function shout() {
            console.log(this);
        }
        shout();
    }
};
obj2.sum2();
/* Получаем простой undefined или с use strict window, так как это простой вызов функции, 
это не метод функции, это функция которая запускается внутри метода, или
как говорится эта функция потеряла контекст вызова, как и у первых примерах */

/* 3 метод. Функции конструкторы */

function User(name, age) {
    this.name = name;
    this.age = age;
    this.human = true;
    this.sayHello = function() {
        console.log(`Hello my name is ${this.name}`);
    };
}
let nurike = new User('Nurike','31'); 
nurike.sayHello();
/* Когда эта функция конструктор будет вызвана, она создаст новый обьект.
Мы чтоб записать какое то свойство, обращаемся к чему-то, к кому-то обьекту.
Внутри функций констукторов, контекст вызова, для всех методов и свойств,
будет только что созданный новый обьект, то есть в данном случае это nurike.
this будет ссылаться тот экземпляр который создали.
И в методе sayHello, this будет ссылаться на тот обьект который создали.
Тоже самое происходит и в классах, о которых поговорим в след уроке 
3) this в конструкторах и классах = новый экземпляр обьекта!!! */

/* 4 метод. Ручное присвоение this любой функции */

function sayName(surname, age) {
    console.log(this);
    console.log(this.name + surname + age);
}

const user = {
    name: 'John'
};
/* И задача такая. Нам нужно чтоб this.name ссылался не на window, 
а на John */

sayName.call(user, ' Smith', ' 23');
sayName.apply(user, [' Smith', ' 23']);
/* Получили в первом консоле, контекст того обьекта, к кому мы привязались,
во вотором консоле, это уже тот свойство которое показывает именно имя.
Функция преобрила свой контекст, благодоря тому что мы использовали
два этих метода, мы четко сказали "Эй функция заработай вот на этом обьекте,
и используй его данные", так что теперь гибко контролировать этот вот
контекст вызова.
Разницы между call apply только в синтаксисе при обращение к именно к аргументам 
call - аргументы записываются через запятую
aplyy - аргументы записываются в массив через запятую */

