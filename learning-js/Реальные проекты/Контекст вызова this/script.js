// Контекст вызова

'use strict';

/* this это то что окружает функцию и в каких условиях оно вызывается.
Для примера, представь человека без определенного места жительства,
и получается что этот человек функционирует в пределах всего мира,
у него нет привязки к конкретному месту, но если мы его поместим
в специальное учреждение, где он сможет жить и чем то заниматься,
то он уже получит так называемый контекст вызова, теперь у него есть
свое место для функционирования.
Функция может вызываться 4-мя способами, и в каждом контекст вызова
отличается */

/* 1 метод это просто вызов нашей функции 
но чтоб увидить этот метод, нужно закоментировать use strict,
и посмотреть эту функцию через браузер */

function showThis() {
    console.log(this);
}
showThis();

/* И видим глобальный обьект window, отсюда делаем вывод.
Если функция просто запускается, вот таким образом,
и когда используем в ней контекст, то этот контекст будет 
ссылаться на глобальный обьект window, это правило верно для
обычного кода, без строго режима, а если запустим такую функцию
со строгим режимом use strict, то jshint сразу начнет ругаться,
и вернет нам undefined. Это первый и самый частый способ
вызова функции, и теперь знаем чему равен this внутри 
такого вызова 
1) Обычная функция: this = window, но если use strict = undefined */

function testThis(a,b) {
    console.log(this);
    function sum() {
        console.log(this);
        /* И в таких задачках часто пишут this.a */
        return this.a + this.b;
    }
    console.log(sum());
}
testThis(5,6);

/* Тут два главных вопроса: 
1) Что выведет в sum console.log(this) какой контеткс вызова у функции sum
2) Будет ли работать этот return и если нет то как его исправить.
1) - Получаем два undefined, вывод такой не важно где функция sum запускается,
главное что у нее контекст вызова будет такой же window или с use strict undefined,
даже если у нас используется функция внутри функции контекст у нее не меняется 
2) - a и b is not defined, короче не видит эти значения, 
испраляем чтоб наша сумма работала, тут достаточно использовать замыкание функции 
function sum() {
        console.log(this);

        return a + b;
    }
    да этих аргументов у sum нет, но засчет того что у нас есть замыкание функции,
    когда запускается sum, она a и b ищет сперва внутри себя она их не находит,
    и она обращается уже к родительской функции testThis, и sum имеет доступ к 
    аргументам a и b у testThis, и которые мы передадим testThis(5,6)
*/
