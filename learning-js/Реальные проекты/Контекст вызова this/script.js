// Контекст вызова

// 'use strict';

/* this это то что окружает функцию и в каких условиях оно вызывается.
Для примера, представь человека без определенного места жительства,
и получается что этот человек функционирует в пределах всего мира,
у него нет привязки к конкретному месту, но если мы его поместим
в специальное учреждение, где он сможет жить и чем то заниматься,
то он уже получит так называемый контекст вызова, теперь у него есть
свое место для функционирования.
Функция может вызываться 4-мя способами, и в каждом контекст вызова
отличается */

/* 1 метод. Это просто вызов нашей функции 
но чтоб увидить этот метод, нужно закоментировать use strict,
и посмотреть эту функцию через браузер */

function showThis() {
    console.log(this);
}
showThis();

/* И видим глобальный обьект window, отсюда делаем вывод.
Если функция просто запускается, вот таким образом,
и когда используем в ней контекст, то этот контекст будет 
ссылаться на глобальный обьект window, это правило верно для
обычного кода, без строго режима, а если запустим такую функцию
со строгим режимом use strict, то jshint сразу начнет ругаться,
и вернет нам undefined. Это первый и самый частый способ
вызова функции, и теперь знаем чему равен this внутри 
такого вызова 
1) Обычная функция: this = window, но если use strict = undefined!!! */

function testThis(a,b) {
    console.log(this);
    function sum() {
        console.log(this);
        /* И в таких задачках часто пишут this.a */
        return this.a + this.b;
    }
    console.log(sum());
}
testThis(5,6);

/* Тут два главных вопроса: 
1) Что выведет в sum console.log(this) какой контеткс вызова у функции sum
2) Будет ли работать этот return и если нет то как его исправить.
1) - Получаем два undefined, вывод такой не важно где функция sum запускается,
главное что у нее контекст вызова будет такой же window или с use strict undefined,
даже если у нас используется функция внутри функции контекст у нее не меняется 
2) - a и b is not defined, короче не видит эти значения, 
испраляем чтоб наша сумма работала, тут достаточно использовать замыкание функции 
function sum() {
        console.log(this);

        return a + b;
    }
    да этих аргументов у sum нет, но засчет того что у нас есть замыкание функции,
    когда запускается sum, она a и b ищет сперва внутри себя она их не находит,
    и она обращается уже к родительской функции testThis, и sum имеет доступ к 
    аргументам a и b у testThis, и которые мы передадим testThis(5,6)
*/

/* 2 метод. Помним что методы обьектов это тоже функции */

const obj = {
    a: 20,
    b: 15,
    sum: function() {
        console.log(this);
    }
};
obj.sum();
/* Получили тот обьект, в котором находится этот метод.
Если мы используем метод внутри обьекта, то контектс вызова
будет ссылаться на этот обьект
2) Контекст у методов обьекта = самому обьекту!!! */

const obj2 = {
    a: 22,
    b: 13,
    sum2: function() {
        function shout() {
            console.log(this);
        }
        shout();
    }
};
obj2.sum2();
/* Получаем простой undefined или с use strict window, так как это простой вызов функции, 
это не метод функции, это функция которая запускается внутри метода, или
как говорится эта функция потеряла контекст вызова, как и у первых примерах */

/* 3 метод. Функции конструкторы */

function User(name, age) {
    this.name = name;
    this.age = age;
    this.human = true;
    this.sayHello = function() {
        console.log(`Hello my name is ${this.name}`);
    };
}
let nurike = new User('Nurike','31'); 
nurike.sayHello();
/* Когда эта функция конструктор будет вызвана, она создаст новый обьект.
Мы чтоб записать какое то свойство, обращаемся к чему-то, к кому-то обьекту.
Внутри функций констукторов, контекст вызова, для всех методов и свойств,
будет только что созданный новый обьект, то есть в данном случае это nurike.
this будет ссылаться тот экземпляр который создали.
И в методе sayHello, this будет ссылаться на тот обьект который создали.
Тоже самое происходит и в классах, о которых поговорим в след уроке 
3) this в конструкторах и классах = новый экземпляр обьекта!!! */

/* 4 метод. Ручное присвоение this любой функции */

function sayName(surname, age) {
    console.log(this);
    console.log(this.name + surname + age);
}

const user = {
    name: 'John'
};
/* И задача такая. Нам нужно чтоб this.name ссылался не на window, 
а на John */

sayName.call(user);
sayName.apply(user);
/* Получили в первом консоле, контекст того обьекта, к кому мы привязались,
во вотором консоле, это уже то свойство которое показывает именно имя.
Функция преобрила свой контекст, благодоря тому что мы использовали
два этих метода, мы четко сказали "Эй функция заработай вот на этом обьекте,
и используй его данные", так что теперь можем гибко контролировать этот вот
контекст вызова.
Разницы между call apply только в синтаксисе при обращение именно к аргументам 
call - аргументы записываются через запятую
apply - аргументы записываются в массив через запятую */

sayName.call(user, ' Smith', ' 23');
sayName.apply(user, [' Smith', ' 23']);

/* Но это были только два варианта присвоения контекста,
3-ий метод присвоения bind, он создает уже НОВУЮ ФУНКЦИЮ,
связанную с определенным контекстом, именно хочу отметить 
что НОВУЮ ФУНКЦИЮ и под нее уже создает контекст. В примере выше
мы новую функцию не вызывали, а просто установили контекст */

function count(num) {
    return this * num;
}
/* Понятное дело что тут не хватает конкретного контекста вызова
который бы умножался на это число которое будет передана при вызове функции,
и вот тут мы можем использовать bind */

const double = count.bind(2);
/* Заметь что в переменную присвоили именно функцию и передаем контекст
вызова 2, она должно удваевать число которое придет в эту функцию. 
То есть 2 переходит в this а num будет передаваться в double */

console.log(double(3));
console.log(double(10));
/* double это новая функция у которой есть жостко привязанный
контекст 2 которая передается в this, и double можем передавать
только один аргумент, который будет удваиваться. Этот метод
будем всега встречать, особенно в React 
4) Ручная привязка this: call, apply, bind */

/* Разобрали 4 способа когда меняется контекст вызова,
используем эти знания на что то более реальное */

const btn = document.querySelector('button');
btn.addEventListener('click', function() {
    console.log(this);
});
/* И при клике на эту кнопку, контекст вызова будет сам элемент
на котором произошло событие, но так работает не всегда.
Если callback функция будет написана в классическом стиле,
то есть через function, а не через стрелочную функцию,
то контекст вызова будет сам элемент на котором произошло событие,
по простому this будет равняться тоже самое что и event.target,
то есть когда мы обращаемся к самому элементу на котором произошло событие */

btn.addEventListener('click', function() {
    this.style.backgroundColor = 'red';
});
/* Кнопка поменяла цвет, тоже самое произойдет при event.target,
это просто для примера, на практике используется обьект события,
а не контекст вызова.
Про нюансы со стрелочной функцией */

const obj3 = {
    num: 5,
    sayNumber: function() {
        const say = () => {
            console.log(this);
        };

        say();
    }
};
obj3.sayNumber();
/* Если была бы обычная функция, то this был бы undefined
или без use strict в window, а так как тут используем
стрелочную функцию, у нее нет своего контекста вызова,
она всегда берет контекст у своего родителя, а родителем
жтой функции является метод sayNumber, а вот у метода,
его контекст это его обьект obj3 в котором он существует. 
И соответственно наш this здесь будет равен нашему
обьекту obj3
const say = () => {
        console.log(this.num);
    };
и тогда получим 5, потомучто у этого this есть
доступ к свойству num, а если переделаем в обычную функцию
уже будет ошибка */

/* Стрелочная функция с обработчиком события */

const btn2 = document.querySelector('button:last-of-type');
btn2.addEventListener('click', (event) => {
    console.log(this);
    this.style.background = 'green';
});

btn2.addEventListener('click', (event) => {
    event.target.style.background = 'pink';
});
/* И видим что контекст потерялся, показывает на window или
с use strict undefined, ну и цвет не меняется,
потому что у стрелочной функции своего контекста вызова нет,
и соответственно она обращается к undefined или к window.
Если у обработчика события прописана обыная фыункция, то
у нее контекст вызова есть, если стрелочная то нет */
