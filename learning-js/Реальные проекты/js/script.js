'use strict';

// ClassList и делегирование событий 

const btns = document.querySelectorAll('button');
console.log(btns[0].classList);
/*
Повторение: просто к btns не можем обратиться, так как
псевдомассив не знает что такое classList, и так что
образаемся к конкретному элементу. Видим что у этого
элемента два класса, и у classList много свойств и методов
*/

//console.log(btns[0].classList.length);  // => 2 класа
//console.log(btns[0].classList.item(0)); // => blue название первого класа
//btns[0].classList.add("red"); 

/*
Добавили клас red, который прописали в css, и кнопка поменяла цвет
*/

//btns[0].classList.remove('blue');   // Удалили клас blue
//btns[0].classList.toggle('blue');

/*
Добавляет клас если не было его, если есть
клас то удаляет его, как бы переключает класы. 
В нашем случае сперва удалили клас blue
потом с помощью toggle добавили. 
Так же в эти методы add,remove и toggle, можем
добавлять не сколько класов
btns[0].classList.add("red", "secondClass"); 
*/

// if (btns[1].classList.contains('red')) {
//     console.log('red');
// }

/*
Метод contains проверяет наличие класа, в нащем 
случае во воторой кнопке нет класа red, поэтому
ничего не выводит. И этот механизм открывает нам двери 
в динамическое преобразование страницы
*/

// btns[0].addEventListener('click', () => {
//     /*
//     Когда кликаем на первую кнопку, и проверяем условие ниже
//     */
//     if (!btns[1].classList.contains("red")) {
//         /*
//         Понять эту строку можно так, если у второй кнопки
//         НЕТ класа red, то добавляем, если есть, то удаляем
//         */
//         btns[1].classList.add("red");
//     } else {
//         btns[1].classList.remove("red");
//     }
// });

/*
Могли бы просто прописать
btns[1].classList.toggle('red');
но в сложных скриптах такое поведение, когда мы задаем
один toggle не всегда дотупно, иногда нужно вручную проверить
есть ли какой то класс, не использовать className так как оно
устарело и не удобна
*/

// console.log(btns[0].className);

/*
И видим что получили список классов как одну строку, 
а не псевдомассив со своими свойствами и методами,
и чтобы манипулировать этими классами нужно постоянно
изменять эту строчку каким либо методом, это крайне
не удобно
*/


// Делегирование событий
/*
Это очень частый прием который часто используется. 
Бывает так что на странице много кнопок, мы хотим что при клике 
на любую из них, вызывалось одно и тоже событие, конечно
можем просто повесить его на каждую кнопку отдельно,
но есть одна очень большая проблема. Если вдруг эта кнопка
или другие какие нибудь тригеры, будут добавляться без
нашего ведома, то событий у них уже не будет, ведь они
не обрабатываются циклом, где мы назначаем событие на
каждую из этих кнопочек, как если бы мы динамически
создали элемент(кнопку), и добавили на страницу, эта
кнопка работать уже не будет, так как она не обрабатывается
обработчиком события, и тут нам поможет делегирование событий.
Суть в чем, мы берем элемент, который является родителем для
всех этих кнопок, и работаем непосредственно с ней, а внутри
будем проверять на что мы кликнули. Нелогичный пример из жизни)
Допустим у нас есть класс(10"А"), и учитель говорит каждому что
завтра субботник, но к нам в класс постоянно приходят новые ученики,
и ведь эти ученики не знают что завтра субботник, и тогда учитель назначает
классного руководителя, который должен следить за всеми учениками
в классе, будто новенькие или старенькие, и говорить им всем о
завтрашнем субботнике
*/

let wrapper = document.querySelector('.btn-block');
wrapper.addEventListener('click', (event) => {
    // console.dir(event.target);
    /*
    Что увидили наш кликнутый элемент в виде обьекта
    и видим свойство tagName = "BUTTON" название того
    тега который используется в HTML структуре 
    */

    if (event.target && event.target.tagName == "BUTTON") {
        /*
        Почему два раза прописали event.target, дело в том
        что в HTML структуре не все элементы поддерживают
        событие click, существуют теги которые просто
        не возможно кликнуть(такой как тег <br>) 
        и у них не будет существовать event.target, поэтому чтоб
        наш скрипт правильно отрабатывал и не выдавал ошибок,
        поэтому мы должны проверить на event.target на его существование.
        Короче проверяем чтоб мы не кликнули на левые теги типа <br>
        */
       console.log('hello');
    }
});