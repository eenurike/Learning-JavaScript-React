'use strict';

// ClassList и делегирование событий 

const btns = document.querySelectorAll('button');
console.log(btns[0].classList);
/*
Повторение: просто к btns не можем обратиться, так как
псевдомассив не знает что такое classList, и так что
обращаемся к конкретному элементу. Видим что у этого
элемента два класса, и у classList много свойств и методов
*/

//console.log(btns[0].classList.length);  // => 2 класа
//console.log(btns[0].classList.item(0)); // => blue название первого класса
//btns[0].classList.add("red"); 

/*
Добавили клас red, который прописали в css, и кнопка поменяла цвет
*/

//btns[0].classList.remove('blue');   // Удалили класс blue
//btns[0].classList.toggle('blue');

/*
Добавляет класс если не было его, если есть
клас то удаляет его, как бы переключает классы. 
В нашем случае сперва удалили клас blue
потом с помощью toggle добавили. 
Так же в эти методы add,remove и toggle, можем
добавлять не сколько классов
btns[0].classList.add("red", "secondClass"); 
*/

// if (btns[1].classList.contains('red')) {
//     console.log('red');
// }

/*
Метод contains проверяет наличие класса, в нашем 
случае во воторой кнопке нет класа red, поэтому
ничего не выводит. И этот механизм открывает нам двери 
в динамическое преобразование страницы
*/

// btns[0].addEventListener('click', () => {
//     /*
//     Когда кликаем на первую кнопку, и проверяем условие ниже
//     */
//     if (!btns[1].classList.contains("red")) {
//         /*
//         Понять эту строку можно так, если у второй кнопки
//         НЕТ класса red, то добавляем, если есть, то удаляем
//         */
//         btns[1].classList.add("red");
//     } else {
//         btns[1].classList.remove("red");
//     }
// });

/*
Могли бы просто прописать
btns[1].classList.toggle('red');
но в сложных скриптах такое поведение, когда мы задаем
один toggle не всегда дотупно, иногда нужно вручную проверить
есть ли какой то класс, не использовать className так как оно
устарело и не удобна
*/

// console.log(btns[0].className);

/*
И видим что получили список классов как одну строку, 
а не псевдомассив со своими свойствами и методами,
и чтобы манипулировать этими классами нужно постоянно
изменять эту строчку каким либо методом, это крайне
не удобно
*/


// Делегирование событий
/*
Это очень частый прием который часто используется. 
Бывает так что на странице много кнопок, мы хотим что при клике 
на любую из них, вызывалось одно и тоже событие, конечно
можем просто повесить его на каждую кнопку отдельно,
но есть одна очень большая проблема. Если вдруг эта кнопка
или другие какие нибудь тригеры, будут добавляться без
нашего ведома, то событий у них уже не будет, ведь они
не обрабатываются циклом, где мы назначаем событие на
каждую из этих кнопочек, как если бы мы динамически
создали элемент(кнопку), и добавили на страницу, эта
кнопка работать уже не будет, так как она не обрабатывается
обработчиком события, и тут нам поможет делегирование событий.
Суть в чем, мы берем элемент, который является родителем для
всех этих кнопок, и работаем непосредственно с ней, а внутри
будем проверять на что мы кликнули. Нелогичный пример из жизни)
Допустим у нас есть класс(10"А"), и учитель говорит каждому что
завтра субботник, но к нам в класс постоянно приходят новые ученики,
и ведь эти новые ученики не знают что завтра субботник, и тогда учитель назначает
старасту, который должен следить за всеми учениками
в классе, будто новенькие или старенькие, и говорить им всем о
завтрашнем субботнике
*/

let wrapper = document.querySelector('.btn-block');
wrapper.addEventListener('click', (event) => {
    // console.dir(event.target);
    /*
    Чтоб увидили наш кликнутый элемент в виде обьекта
    и видим свойство tagName = "BUTTON" название того
    тега который используется в HTML структуре 
    */

    // if (event.target && event.target.tagName == "BUTTON") {
    //     /*
    //     Почему два раза прописали event.target, дело в том
    //     что в HTML структуре не все элементы поддерживают
    //     событие click, существуют теги на которые просто
    //     не возможно кликнуть(такой как тег <br>) 
    //     и у них не будет существовать event.target, поэтому чтоб
    //     наш скрипт правильно отрабатывал и не выдавал ошибок,
    //     поэтому мы должны проверить на event.target на его существование.
    //     Короче проверяем чтоб мы не кликнули на левые теги типа <br>,
    //     и мы будем кликать только элементы с event.targer
    //     */
    //    console.log('hello');
    //    /*
    //     Типичное приминения делегирования, так же можно проверять 
    //     на nodeName, классы и т.д.
    //    */
    // }

    // if (event.target && event.target.classList.contains('blue')) {
    //     console.log('hello');
    // }
    /*
    Делегирование - если элемент подходит под условие, то на нем будет срабатывать 
    та функция, кторую мы наптсали или передали, мы делегируем событие с родителя 
    на его потомков, и теперь на лету можно добавить хоть с десяток кнопок и они
    будут выполнять нужные действия 
    */

    if (event.target && event.target.tagName == "BUTTON") {
        console.log('hello');
    }
});

let btn = document.createElement('button');
btn.classList.add('red');
wrapper.append(btn);
/*
И видим что кнопка успешно нажиматся, даже если обработчик обьявлен 
выше чем созданная кнопка. И так память компа расходуется намного меньше,
так как обработчик события всего один, а при классическом способе, мы каждому
элементу добавляли обработчик события
*/