'use strict';

// Функции это наши действия в JS, они используют различные типы данных и изменяют информацию так как мы ей укажем, так же это значительно сокращает наш код прямо как циклы. Можно функцию представить как калькулятор, нам нет нужды каждый раз вводить какие-то математические вычисления, мы просто вводим числа и калькулятор делает все за нас, сама эта структура это просто набор функций сложение/вычитание/деление/умножение, если открыть инженерный калькулятор, то там намного больше будет функций. Тоже самое можно сказать про микровалновку, холодильник у всех них есть какие-то функции, которые они выполняют

function showFirstMessage() {
  // Имя функции может быть любым, но только осмысленным, имя должно быть глаголом с припиской того над чем выполняется действие. В круглые скобки будем передавать аргументы функции
  console.log('Hello World!');
}
// Сейчас функция просто существует в коде, она никак не выполняется, она просто есть, для того чтобы она заработала, ее нужно вызвать
showFirstMessage(); // Hello World!

// Есть и функции анонимные, то есть без имени. Они вызываются и используются здесь и сейчас только один раз, поэтому впринципе им имя давать и не нужно. Анонимные функции разберем дальше

// У функции есть так же и аргументы, которые записываем в круглые скобки. Когда функция вызывается, мы можем ей дать какие-то данные которые она будет использовать внутри себя. Опять напримере калькулятора, мы как функцию передаем два аргумента, нажимаем 4, затем +, затем 6 и нажимаем =, и калькулятор показывает результат 10. Это мы передали два аргумента 4 и 6 в функцию сложения

function showFirstMessage2(text) {
  console.log(text);
}

showFirstMessage2('Hello World!');
// Когда функция запустится, она возмет эту строку Hello World! которую мы ей передали, подставит ее вместо аргумента функции, и потом засунет в console.log

// Если вдаваться в детали, то аргументов на самом деле может быть бесконечное кол-во showFirstMessage(text, arg, num, и т.д.). Чуть позже познакомимся с одной фишкой нового стандарта, для того чтобы быстро указать что этих аргументов у нас может быть много, но на баззовом уровне такой REST оператор пока не нужен

//Как ведут себя переменные в функциях

function showSecondMessage(text) {
  console.log(text);
  let num = 20;

}

showSecondMessage('Hello World!');
console.log(num);
// num is not defined. Когда мы обьяевляем переменную внутри функции, то снаружи она уже не доступна. Такие переменными называются локальными, она существует только внутри функции

let num2 = 20;
// Так мы обьявили глобальную переменную

function showSecondMessage(text) {
  console.log(text);
  num2 = 30;
  // А здесь мы уже ее переиспользовали, и это значит что любая фукнция, она может спокойно брать и использовать глобальную переменную внутри себя
}

showSecondMessage('Hello Nurike!');
console.log(num2);
// 30, Потомучто мы в функции переназначили переменную

let num3 = 20;

function showSecondMessage(text) {
  console.log(text);
  let num3 = 10;

}
// Это две разных переменных

showSecondMessage('Hello Nurike!');
console.log(num3);
// 20, он видит глобальную переменную, а локальная скрыта

// Замыкание функций - это сама функция вместе со всеми внешними переменными которыми ей доступны

let num4 = 20;

function showSecondMessage(text) {
  console.log(text);
  let num4 = 10;
  console.log(num4);  // 10
}
// Эта переменная num4 которая внутри функции, когда код доходит до console.log(num4), она сперва начинает искать эту переменную внутри функции, находит и выводит ее

showSecondMessage('Hello Nurike!');
console.log(num4); // 20

let num5 = 20;

function showSecondMessage(text) {
  console.log(text);
  console.log(num5); // 20
}
// Но если в функции нет переменной num5, функция начинает искать на уровень выше, находит глобальную переменную num5, и выводит уже ее

showSecondMessage('Hello Nurike!');
console.log(num5);  // 20

// Функция так же может вернуть нам какое либо значение, при помощи ключевого слово return, как только функция увидит return она прекратит свое действие. return позволяет нам вернуть какое либо значение во внешний мир

function calc(a, b) {
  // let plus = a + b;
  // return plus; ИЛИ
  return (a + b);
  // Можно и без скобок, скобки для того чтоб просто сгрупировать это значение
}
// Когда запустится функция calc она нам вернет сумму первого арнумента и второго, и эта маленькая функция уже решает за нас очень многие проблемы, так как мы ее можем переиспользовать много раз

console.log(calc(5, 6));  // 11
console.log(calc(2, 40)); // 42
console.log(calc(1, 2));  // 33
console.log(calc(9, 1));  // 10
// И теперь просто переиспользуем эту функцию с разными аргументами, в этом и заключается суть функций, автоматизация наших процессов.

function calc(a, b) {
  return (a + b);
  //console.log(num2);
  // Unreachable, не читаемый код, так как после return, дальше идет мертвый код. return это окончание функции
}

// Но у return есть еще одно применение, не только окончание функции, но и возвращение значения наружу
function ret() {
  let num = 20;
  return num;
  // То-есть во внешний мир наша функция возвращает значение своей локальной переменной, этот прием в практике очень часто используется, ведь в функции может выполнятся какой-то огромный код, какая-то логика по работе с зарплатами, с какими-то данными и прочим, и вконце нам возвращается результат работы этой функции, и его мы уже можем куда-то записать
}

console.log(ret()); // 20
const anotherNum = ret();
console.log(anotherNum);  // 20

// Классификация функций
// 1) Function Declaration - это по факту функции которые мы уже использовали, и у нее есть одна очень важная особенность, она существует еще до того как наш код запустится, как переменная var. Работает это так наша html страница она загружается, у нее все идет по порядку, потом доходит до скрипта дело, скрипт начинает загружаться, первым делом браузер пробигается по скрипту, и находит все переменные var если они есть и все function declaration. Он их создает, он их обьявляет, и после этого наш код начинает выполнятся. И какое приемущество у этого подхода есть, если функция существует до того как она была обьевлена
console.log(testFun('nurike', ' is a great Frontend Developer'));

function testFun(a, b) {
  return a + b;
}
// Иногда разработчики такой прием применяют, что все функции которые созданы в одном из файлов, они помещают их в самый низ страницы, а сверху просто используют, ну это уже стилистика у каждого разработчика будет своя

// 2) Function Expression - функциональное выражение, тут синтаксис немного отличается, мы должны создать переменную и во внутрь положить какую-то функцию
const logger = function() {
  console.log('Hello');
};

logger();
// Такая функция создается только тогда, когда до нее доходит поток кода, и ее можно вызвать только после ее обьвления
// logger();

// const logger = function() {
//   console.log('Hello');
// };
// Так уже мы сделать не можем, выдаст ошибку

// 3) Стрелочная функция, был добавлен в стандарте ES6
// const calc2 = (a, b) => a + b; это сокращенный вариант, если функция только в одну строку, то можно опускать фигурные скобки и более того пишем даже без return, и такой способ очень часто будем встречат, более того если один аргумент, можно записать и так
// const calc2 = a => a + b;
// Понятное дело такой синтаксис очень сильно позволяет сократить код, однако перед тем как ее использовать нужно знать ее особенности. Такая функция не имеет контекста вызова, поэтому ее часто можно встретить в обработчиках события, ну эти темы дальнейших уроков. Пока что помни у нее есть свои особенности и везде прям ее использовать нельзя, хотя очень хотелось бы
const calc2 = (a, b) => {
  console.log('This is function');
  return a + b;
};
//  А если функция в несколько строк, пишем как обычно

// Еще раз про аргументы функции и почему это важно
// Конечно любые операции в коде мы можем записать в потоке кода, но они выполняются только один раз, когда код дойдет до них. Если же это действие мы хотим повторить несколько раз в будущем, то стоит создавать функцию, например функция перещета курса валют, пользователь вводит разные значения, а у нас должна быть функция которая каждый раз будет пересчитывать результат. Нужно знать что функция каждый раз получает новое значение для пересчета

function convert(amount) {
  console.log(28 * amount);
  // Допустим 28 сегоднейший курс
}

convert(500); // Допустим хотим конвертировать 500 по курсу 28
// Очень важная деталь, функция изначально незнает какое значение введет ему пользователь, точно так же как и на сайте курса валют, это очень важно так как значение подставляется только во время вызова этой функции, а в самом значении она определяется как аргумент. И вообще можем сделать так что и курс валют наша функция не будет знать, эти данные будут приходить к нам от банка
const usdCurr = 28;

function convert(amount) {
  console.log(usdCurr * amount);
}
// Так тоже будет работать, но тогда функция четко привязывается к переменной, а именно к значению 28, а мы хотим сделать чтоб наша функция была универсальной
const usdCurr2 = 28;

function convert(amount, curr) {
  // Возможно мы потом будем подставлять какой-то другой курс валют, или другую валюту, поэтому создали еще один аргумент curr, в который уже будет приходить какой-то другой курс
  console.log(curr * amount);
}

convert(500, usdCurr2);
// Крч мы вызываем функцию и помещаем в нее переменную usdCurr2 со значение 28, и она идет в аргумент функции, потом эта переменная со значением подставляется в наш console.log и умножается. Функция каждый раз будет выдавать результат на основании данных которые в нее уже пришли, это и есть очень важная деталь, мы функцию делаем универсальной, не зависящих от конкретных значений

// const usdCurr2 = 28;

// function convert(amount) {
//   console.log(usdCurr2 * amount);
// }

// convert(500);
// А если в функции жестко привязана какая-то переменная, то нам намного сложнее будет отследить как эта функция работает, представь что в этой функции может быть десятки сотни строк кода, и ты видишь вызов функции где просто написано convert(500), и тебе придется смотреть в функцию и искать какая переменная жетско привязанна

// Еще раз пример с обменикам валют, это такой реальный пример который используется на сайтах обмениках, может быть много разных валют и разных курсов
const usdCurr3 = 28;
const eurCurr = 50;
const rusCurr = 48;

function convert(amount, curr) {
  console.log(curr * amount);
}

convert(500, usdCurr3); // просто как пример, 500 доларов это 14000 тенге
convert(500, eurCurr);  // 500 евро это 25000 тенге
convert(500, rusCurr);  // 500 рублей это 24000 тенге
// Теперь мы просто можем вызвать функцию с нужным аргументом, и теперь в эти аргументы можем передавать какой угодно курс валют, какую угодную переменную

// А теперь представь что если бы второго аргумента не было, и было бы куча валют
const usdCurr4 = 28;
const eurCurr4 = 50;
const rusCurr4 = 48;

function convertUsd(amount) {
  console.log(usdCurr4 * amount);
}

function convertEur(amount) {
  console.log(eurCurr4 * amount);
}

function convertRus(amount) {
  console.log(rusCurr4 * amount);
}

convertUsd(500);
convertEur(500);
convertRus(500);
// Все тоже самое, но смотри сколько функций мы наплодили(грязный код), когда там была всего одна функция для ковертации. Действия ведь одни и теже, даже если бы действия не много отличались, могли бы использовать условия, так что всегда думай, как сделать более короче и красивее. Здесь мы соблюдаем принцип DRU(don't repeat your self) не нужно повторять код там где можно этого не делать, в нашем случае при помощи одной функции избежали всего этого. А вот если создавать десяток отдельных, не универсальных функций, то таким образом вы пишите плохой код и нарушаете этот принцип. И конечно же чем сложнее будет код, тем сложнее будут связи между аргументами и всем прочим

// Про важность return
// Любая функция может вернуть как результат своей работы а может и ничего не возвращать зависит от задачи которая она решает

const usdCurr5 = 28;

function convert(amount, curr) {
  console.log(amount + curr);
  // Эта функция занимается тем что выдает результат, но она его дальше никуда не передает, этот результат просто выводится в консоль. Нужен ли в коде нам какой-то результат, думаю что нет, потомучто в консоле мы вопелнели основное действие и все, функция выполнила свое главное действие. Но давайте развивать дальше ситуацию, если полученное значение нам понадобится дальше, то как это вообще будет выглядеть, полученная сумма у нас будет уменьшена из-за скидки
}
convert(500, usdCurr5);

const usdCurr6 = 28;
const discount = 0.9;

function convert(amount, curr) {
  return amount * curr;
  // Эта функция возвращает конвертированную сумму 
}

function promotion(result) {
  console.log(result * discount);
  // Эта функция отвечает за умножение конвертированной суммы на скидку discount
}

promotion(convert(500, usdCurr6));
// Интересный момент, мы можем в функцию promotion засунуть в виде аргумента другую функцию. Что здесь происходит, у нас как и раньше запускается функция convert, и она теперь возвращает какой-то результат, то есть какое-то число, причем мы ее вызвали с аргументами и когда она закончит свою работу она возвратит нам результат, этот результат(число) уже в качестве аргумента пойдет в function promotion(result) сюда, и потом с этим результатом уже что-то будет происходить. Конечно далеко не всегда удобно записывать функцию внутри функции, поэтому частенько будем использовать какой-то промежуточный результат
const res = convert(500, usdCurr6);
promotion(res);
// Самое главное что мы сделали с функцией convert, то что она возвращает какой-то результат, а другая функция promotion уже с ним что-то делает, то есть выводит в консоль. Поэтому когда пишите функцию вы должны представлять что она будет делать и как использоваться. В фунции может быть много каких-то действий расчетов, выводов в консоль и т.д., все это вполне допустимо. Конечно желательно чтоб функция выполняла какое-то одно действие, не смешивать в кучу все подряд, потому-что это будет не удобно и не практично

// Стоит так же сказать после ключевого слово return может быть возвращенно любое занчение: просто число, обьект, массив, какая-то другая функция и т.д. это уже более сложные шаблоны с которыми стоит знакомится постепенно. Например в основе приема компонента высшего порядка, лежит то что функция возвращает другую функцию

function anotherFunction() {
  console.log('something');

  return function(){};
}

// И запомни что все сложные приемы на самом деле состоят из вот таких базовых вещей

// return на самом деле можно вообще использовать и без значений
function test() {
  for (let i = 0; i < 5; i++) {
    console.log(i);
    if (i === 3) return;
    // Здесь можно записать и без фигурных скобок, потому что это одно не большое действие, поэтому такой синтаксис тоже допустим, да на него могут ругаться JSHint, но это тоже допустимый вариант. Крч когда итератор дойдет до 3, не только цикл прекратит свою работу но и  вся функция тоже
  }
  console.log('done');
  // Для теста специально после return записали что-то для вывода в консоле, и после 3 ничего не видим, функция прекратила свою работу
}
test();
// Данный прием действительно полезен когда нужно завершить работу функции

// Но в голову может прийти филосовский вопрос, а что вообще тогда возвратит return, он возвратит undefined. На самом деле любая функция что-то возвращает, даже если вы не используете return, но на уровне кода, самого движка JS, функция все равно закончится return undefined 
// function promotion(result) {
//   console.log(result * discount);
//   return undefined; что-то вроде такого, но код это делает внутри, и все делает за нас
// }
function doNothing() {} // Пустая функция
console.log(doNothing() === undefined); // true
// Это простое докозательство того что функция нам все равно что-то возвращает
