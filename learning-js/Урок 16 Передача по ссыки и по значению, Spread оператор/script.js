'use strict';

let a = 5,
    b = a;

b += 5;
// Анологично этой записи b = b + 5

console.log(b); // 10
console.log(a); // 5

const obj = {
  a: 5,
  b: 1
};

const copy = obj;

copy.a = 10;

console.log(copy);  // { a: 10, b: 1 }
console.log(obj);   // { a: 10, b: 1 }
// И получаем вот такую картину, в консоле получаем два обсулютно одинаковых обьекта, хотя мы создали копию const copy = obj;, и уже у копии только поменяли значение, а не сам изначальный обьект. На практике видим что изменяя что-то внутри копии, мы модифицируем наш изночальный обьект. То-есть эта конструкия не сработала const copy = obj; или сработала как-то не правильно

// Обрати на это особое внимание на эту тему, потому-что в будущем могут быть проблемы, если не поймете как это все работает
// Когда мы работаем с какими-то примитивными типами данных(строки, числа, логических значений) то они передаются по значению, проще говоря когда прописываем такую конструкцию let a = 5, b = a; и работая с примитивными типами данных, то b заменяется на 5. А когда работая с какими-то обьектами(обьекты, массивы, функции, какие-то спецефичиские обьекты типа обьект даты) то у нас здесь идет передача уже не по значению а по ссылке, то есть здесь const copy = obj; мы не скопировали новый обьект, мы передали copy ссылке на обьект obj. Это значит что obj она передает не саму структуру обьекта, она передает именно ссылку. И это обозначает, что мы модифицируя копию copy.a = 10; мы как бы модифицируем нащ изначальный обьект, потомучто мы работаем не с копией этого обьекта, а именно с сылкой на предыдущую структуру, в нашем случае это обьект. Такое поведение называется передача по ссылке

// Создаем копии таких структур
// Способ 1 с помощью цикла(перебора обьекта)

function copyObj(mainObj) {
  let anotherObj = {};

  let i;  // Можно вынесни переменную
  for (i in mainObj) {
    anotherObj[i] = mainObj[i];
    // В пустой обьект копируем свойтва нового обьекта, то есть по простому, мы пройдемся по старому обьекту скопируем все свойства и поместим их точно так же в новую копию
  }
  return anotherObj;
}


const numbers = {
  a: '555',
  b: 2344,
  c: {
    x: 7,
    y: 4
  }
};

let newNumbers = copyObj(numbers);
console.log(newNumbers);
// Теперь мы совершили именно клонирование обьекта, убедимся в этом

newNumbers.a = 555;
console.log(numbers);
// Видим что в основном обьекте значение в a осталось в строковом типе данных '555'
console.log(newNumbers);
// А копия поменяла занчение в числовой тип данных 555

// Но если такой обьект протестируем более тщательно
newNumbers.c.x = 70;

console.log(newNumbers);
console.log(numbers);
// То заметим значение в свойтве x поменялось в двух местах. Когда мы клонируем обьекты есть два важных понятия, это глубокие и поверхностные копии обьекта. Сейчас мы создали поверхностную копию обьекта, потому что она берет все обычные свойства кторые были в родителе и создает как бы независимые структуры, но как только появляется вложенная структура, одно из свойств будет содержать обьект или массив, то это своство будет иметь опять же ссылочный тип данных. Чуть дальше по курсу научимся создавать и глубокие копии

// Способ 2 Object.assign. У нашего глобального типа данных Object есть такой метод, который позволяет соединить сразу несколько обьектов, то есть у вас есть какой-то большой обьект и мы во внутрь хотим поместить еще один обьект поменьше у которого еще будет несколько свойств 

const numbers2 = {
  a: '555',
  b: 2344,
  c: {
    x: 7,
    y: 4
  }
};

const add = {
  d: 22,
  e: 18
};
// И теперь хотим в обьект numbers2 поместить обьект add

console.log(Object.assign(numbers2, add));
// В первый аргумент передаем тот обьект в который мы хотим все это поместить, и вторым аргументом идет тот обьект который помещаем. Видим что два обьекта соединились, но самое главное что чейчас мы создали независимую поверхнустную копию обьекта, то есть она никак не зависит не от add не от numbers2, только если не считать вложенную структуру в виде свойства с

// Тоже самое мы можем сделать с пустым обьектом чтобы создать просто копию обьекта
const clone = Object.assign({}, add);

clone.d = 15;

console.log(add); // { d: 22, e: 18 }
console.log(clone); //{ d: 15, e: 18 } 
// В clone лежит поверхностная копия обьекта add

// В JavaScript очень много структур состоят имеено из обьектов и массивов, и мы с ними будем работать постоянно. Поэтому глубокое понимание работы с обьектами это из важнейших навыков которые будут у вас как у разработчика

// Способ 3. Частный случай обьектов. МАССИВЫ
// Чтобы создать копию массива, мы конечно же можем так же воспользоваться каким-то там циклом, написать функцию для этого, но так же есть и метод чтоб создать копию массива

const oldArray = ['a', 'b', 'c'];
// const newArray = oldArray;
// Если вот так оставим структуру, то в newArray просто передастся ссылка на oldArray
const newArray = oldArray.slice();
// Этот метод который просто позволяет скопировать старый массив, в него еще можно передать аргументы по кол-во этих элементов
newArray[1] = 'asdsdsdsd';
console.log(oldArray);  // [ 'a', 'b', 'c' ]
console.log(newArray);  // [ 'a', 'asdsdsdsd', 'c',]

// Новые стандарты ES6 и ES8
// Способ 4. Оператор разворота. в ES6 стандарте такой оператор появился для массивов, а в ES8 стандарте уже и для обьектов. Этот оператор называется spread оператор(оператор разворота) - он разворачивает структуру и превращает ее просто в набор каких-то данных

const video = ['youtube', 'vimeo', 'rutube'],
      blogs = ['wordpress', 'livejournal', 'blogger'],
      internet = [...video, ...blogs, 'vk', 'facebook'];  // Такой синтаксис позволит нам просто вытащить эти элементы, которые будут через запятую, и они все будут помещаться в переменную internet, и добавили свои какие-то данные
console.log(internet);  // ['youtube','vimeo','rutube','wordpress','livejournal','blogger','vk','facebook']
// Оператор разворота просто развернул эти структуры на отдельные элементы

function log(a, b, c) {
  console.log(a);
  console.log(b);
  console.log(c);
}

const num = [2, 5, 7]; 
// Допустим этот массив к нам пришел с сервера, то есть он сформировался где-то на стороннем ресурсе и он нам пришел в таком виде. Представь что вместо этих цифр могут прийти данные о каком-то видео: ссылка на сам источник, ссылка на заглушку(картинка), ссылка на автора. И все эти три аргумента нам необходимо передать в функцию log, но как это сделать, ведь функция принимает три отдельных элемента, она не принимает массив и здесь нам идет на помощь spread оператор
log();
// Но вместо того чтоб передать три аргумента
log(...num);  // 2 5 7
// Теперь этот массив просто разложится на три отдельных элемента, и эта функция запустится уже с этими тримя элементами. Вот с такой конструкцией будем работать часто, особенно во второй части курса, там где будем использовать библеотеку React

// Способ 5. Создаем поверхностную копию массива и обьекта с помощью spread оператора
//Массив
const array = ['a', 'b'];
const newArray2 = [...array];

newArray2.push('c');
console.log(array);
console.log(newArray2); 

// Обьект
const objMain = {
  one: 1,
  two: 2
};

const objCopy = {...objMain};

objCopy.three = 3;
console.log(objMain);
console.log(objCopy);







