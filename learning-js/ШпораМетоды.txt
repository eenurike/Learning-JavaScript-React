СТРОКИ
--------------------------------------------------------------------------------------------------------------------
const str = 'test';

console.log(str.length);  // 4, это кол-во символов внутри строки и это часто используемое свойство для того чтоб получить длину как строки, так и других типов данных
const arr = [1, 2, 3];

console.log(arr.length);  // 3, 3 элемента внутри массива
Обрати внимание что когда используем СВОЙСТВА, мы его никак не вызываем, оно просто пишется через точку, а методы которые будут вспомогательными функциями, они уже будут вызываться с помощью круглых скобок

В самом браузере можно посмотреть все методы кого-то элемента, например тип данных Number. В браузере в консоле пишем console.dir(Number);

console.log(str[2]); // s, Получили третью букву из нашей строки, в реальных задачах такой подход используется довольно редко, новечьки допускают частую ошибку делаю вот так
console.log(str[2] = 'd');
Тоесть получили какой-то символ и пытаются его поменять
console.log(str); 
Но мы не получили желаемого результата tedt, а получили прежнее значение test. Строку мы напрямую поменять не можем, для этого есть методы

console.log(str.toUpperCase()); // TEST, меняет строку на верхний регистр, мы выполнели какое-то действие над строкой
console.log(str); // test, но предыдущее значение не поменялось
Дело в том что str.toUpperCase() оно возвращает новое значение, оно напрямую не меняет ту строку которая была там, а уже это новое значение может где использовать, записать в консоль или засунуть в другую переменную и т.д. А наш исходник не меняется

const strLower = 'teSt';
console.log(strLower.toLowerCase()); // test

Превращает строку в нижний регистр. Такое в практике довольно часто бывает, когда например пользователь вводит какие-то данные на сайте, он может по ошибке написать какую-то букву с большой буквы, и когда мы уже будем обрабатывать эти данные, мы будем превращать все в нижний регистр

Метод который позволяет найти кусочек вашей строки и сказать с какого индекса она начинается, в официальной документации этот метод называется "Поиск под строки"

const fruit = 'some fruit';

console.log(fruit.indexOf('fruit'));  // 5, Тоесть слово fruit у нас наченается с 4-го индекса. Этот метод должен уже принимает в себя какой-то аргумент. Самое очевидное использование этого метода для того чтобы увидеть что этот кусочек дествительно существует, но иногда этот метод используется для того чтобы определить, а действительно ли в этой строке есть искомое значение
console.log(fruit.indexOf('q'));  // -1, Так как такой буквы нет в нашей строке

const logg = 'Hello World';
console.log(logg.slice(6, 11));  

World, Вырезали слово world из нашей строки, у этого метода первый аргумент это с какой части строки будем возвращать что-то, второй аргумент это где заканчивать вырезание строки. Так по логике должно было быть 10 а не 11, дело в том что не включая 10 букву

console.log(logg.slice(6));  

World, Если один аргумент, то вырезается с указаного начала и до конца

console.log(logg.substring(6, 11)); 
Он похож на slice, но только первый метод может быть больше второго (но не стоит так делать), и он не поддерживает отрицательные значения. Решай сам какой из способов использовать, просто помни такие не большие особенности

console.log(logg.substr(6, 5));
Этот метод вторым аргументом говорит сколько символов вырезать 

let a = prompt('Один из последних просмотренных фильмов?').trim(),
Метод trim уберает пробелы вконце и вначале строки, а если все пробелы то возвращает пустую строку, могли бы записать следующей строкой a.trim(), но зачем когда можно сразу сделать. Не учли то что пользователь может ввести пробелы. Область применения этого метода сводится не только к работе с данными, который ввел пользователь, хотя чаще всего это и есть его основная задача, так же вам могут приходить некоректные данные от сервера или пробелы случайно будут попадать в строку при выполнения некоторых функций

--------------------------------------------------------------------------------------------------------------------
ЧИСЛА
--------------------------------------------------------------------------------------------------------------------

Для работы с числами в JS есть мини билиотека в самом браузере. В консоле пишим Math. и дальше выпадает список из всех методов (синусы, косинусы, максимальное значение, минимальное значение и т.д.) остановимся на округлении 

const num = 12.2;
console.log(Math.round(num)); // 12, округляет до ближайшего целого числа
В практической деятельности довольно редко придется работать с чем-то кроме округления. Такие функции как синусы, косинусы в вебе они довольно редко используются

const test = '12.2px';  
Допустим очень такой распространенный случай когда мы получаем такое значение со страницы, это размеры определенного элемента
console.log(parseInt(test));  // 12 причем это уже числовой тип данных, На самом деле этот метод который вызывается на числах Number.parseInt(), но для удобства разработчики вынесли его в отдельную глобальную функцию которую мы просто можем вот так вызывать. parseInt занимается тем что переводит число в другую систему исчесления: есть десятичная система исчиления (1,2,3,4 и т.д.), двоичная (0.1, 0.2, 3.5), но на самом деле есть много различных таких систем

console.log(parseFloat(test)); // 12.2 он возвращает значение с плавающей точкой(то есть с дробными значениями), этот метод изначально служит для того чтобы взять какое-то число либо строку и вернуть нам в десятичном варианте

--------------------------------------------------------------------------------------------------------------------
ОБЬЕКТЫ
--------------------------------------------------------------------------------------------------------------------

const obj = new Object();
Обычно таким способом никогда не пользуются 

const options = {
  name: 'test',
  width: 1024,
  height: 1024,
  colors: {
    border: 'black',
    bg: 'red'
  }
};

Если нужно удалить какое-то значение нужно использовать специальный оператор

delete options.width;

console.log(options);
Удалили свойство width, но если нужно удалить сразу несколько обьектов нужно запускать цикл, который будет на какие-то параметры ориентироваться и удалять определенные свойтсва

Иногда нам нужно перебрать обьект
for (let key in options) {
  Это цикл будет работать столько раз, сколько свойств находится внутри этого обьекта, и переменная key обращается именно к ключам обьекта
  // console.log(`Свойство ${key} имеет значение ${options.key}`);
  console.log(`Свойство ${key} и его значение ${options[key]}`);
}

Заметь если обращаться через точку ${options.key}, то мы почему-то получаем результат 'Свойство width имеет значение undefined, но если записать ${options[key]}, то все нормально
Очень интересный момент, что вложенный обьект консоль вывел нам как "Свойство colors и его значение [object Object]", это все потому что мы все значение выводим в качестве строк, и когда цикл натыкается на вложенные обьект, он его не может переобразовать в строку, и он просто передает строковое предствавление обьекта, консоль не выдает ошибку, консоль просто говорит что это обьект который он не может превратить в строку

for (let key in options) {
  console.log(typeof(options[key]));
}
Видим что одно из значений является обьектом

for (let key in options) {
  if (typeof(options[key]) === 'object') {
    То есть мы проверяем, если по типу данных значение будет object, то запускаем еще один перебор
    for (let i in options[key]) {
      // Как бы key отвечает за основной обьект а i вложенный обьект, и мы перебираем свойства(i) у вложеного обьекта(key)
      console.log(`Свойство вложеного обьекта ${i} и его значение ${options[key][i]}`);
      // options[key] это мы перебираем обьект options, и то что бы достучаться до значения в обьекте colors мы можем использовать двойные options[key][i]. Это как бы если мы обратились options['colors']['border']
    }
  } else {
    console.log(`Свойство обьекта ${key} и его значение ${options[key]}`);
  }
}

Кстати у обьекта нет свойства length, и это очень интересная задача, потому что там используется прием счетчика, и это очень чатсый прием на первых порах
let counter = 0;

for (let key in options) {
  counter++;
}
То есть счетчик пробегается по каждому свойству и увеличивает счетчик
console.log(counter); // 4, но без свойств во вложенном обьекте

counter = 0;
for (let key in options) {
  if (typeof(options[key]) === 'object') {
    for (let i in options[key]) {
      counter++;
    }
  }
  counter++;
}

console.log(counter); // 6 Это уже со свойствами во вложенном обьекте

Но этот способ не совсем удобнен, и тут мы знакомимся с методом для обьекта
console.log(Object.keys(options)); // [ 'name', 'width', 'height', 'colors' ]
Этот метод берет наш обьект и на его основании создает массив в котором все элементы это ключи, ну и мы уже знаем как можно подсчитать кол-во значений в массиве
console.log(Object.keys(options).length); // 4
console.log(Object.keys(options).length + Object.keys(options.colors).length);  // 6 с вложенными свойствами

Таких методов у Object много, будем проходить их в течении курса. Но и такие методы мы можем создавать вручную, помним что методы это дейсвия которые может делать наш обьект

const options2 = {
  name: 'test',
  width: 1024,
  height: 1024,
  colors: {
    border: 'black',
    bg: 'red'
  },
  makeTest: function() {
    console.log('  test  '.toUpperCase().trim());
    Вот и наш собственный метод который будет работать внутри options. Это тоже самое что и когда мы прописывали Object.keys(options) именно .keys() это и есть метод, только эти методы уже встроены в JS, а эти мы создаем сами. И помни что в таком состоянии наш метод просто существует, а потом его нужно запустить(вызвать)
  }
};

options2.makeTest();  // запускаем(вызываем) наш метод и получаем 'TEST' без пробелов и в верхнем регистре

Object.assign. У нашего глобального типа данных Object есть такой метод, который позволяет соединить сразу несколько обьектов, то есть у вас есть какой-то большой обьект и мы во внутрь хотим поместить еще один обьект поменьше у которого еще будет несколько свойств 

const numbers2 = {
  a: '555',
  b: 2344,
  c: {
    x: 7,
    y: 4
  }
};

const add = {
  d: 22,
  e: 18
};
// И теперь хотим в обьект numbers2 поместить обьект add

console.log(Object.assign(numbers2, add));
// В первый аргумент передаем тот обьект в который мы хотим все это поместить, и вторым аргументом идет тот обьект который помещаем. Видим что два обьекта соединились, но самое главное что сейчас мы создали независимую поверхнустную копию обьекта, то есть она никак не зависит не от add не от numbers2, только если не считать вложенную структуру в виде свойства с

// Тоже самое мы можем сделать с пустым обьектом чтобы создать просто копию обьекта
const clone = Object.assign({}, add);

clone.d = 15;

console.log(add); // { d: 22, e: 18 }
console.log(clone); //{ d: 15, e: 18 } 
// В clone лежит поверхностная копия обьекта add

// Обьект
const objMain = {
  one: 1,
  two: 2
};

const objCopy = {...objMain};

objCopy.three = 3;
console.log(objMain);
console.log(objCopy);

--------------------------------------------------------------------------------------------------------------------
МАССИВЫ
--------------------------------------------------------------------------------------------------------------------

const arr = [1, 2, 3, 4, 5, 6, 7];
Часто при работе с массивами мы хотим его просто редактировать, либо хотим добавить, либо удалить элемент с массива и для этого у нас есть методы как для работы с концом массива так и с его началом

arr.pop();
Он удаляет последний элемент с массива
console.log(arr); // [ 1, 2, 3, 4, 5, 6 ]

arr.push(777);
Добаляет элемент в конец массива
console.log(arr); // [ 1, 2, 3, 4, 5, 6, 777 ]

Если же говорить о начале нашего массива, то существуют такие методы как shift и unshift, которые удаляют и добавляют элементы соответственно, но у них есть большой недостаток из-за которого их очень редко используют. Когда мы работаем с концом массива, у них есть элементы, у них есть свои порядковые номера и мы просто вконце меняем что-то, если удаляем то у нас просто исчезает последний элемент, если добавляем то нам всего лишь неебходимо добавить элемент вконец и ему назначается порядковый номер. Но как только мы начинаем работать с началом массива, все уже совсем подругому. Если нам необходимо вставить элемент в начало массива const arr = [0, 1, 2, 3, 4, 5, 6, 7];, нам здесь необходимо выполнить не только вставку элемента, так же у всех остальных элементов будут идти после, нам необходимо поменять индекс у этих эдементов, элемент который раньше был 1 у него индекс был 0, а теперь мы добавили в начало элемент, теперь этот же элемент 1 имеет уже индекс 1, и так со всеми элементами в массиве. Сейчас маленький массив, но в будущем, вы будете работать с массивом у которого может быть 1000-2000 элементов, и такая операция может занять очень много времени по меркам программирования. Тоже самое происходит если мы удаляем элемент, удалили элемент, и у остальных элементов нам придется менять индексы. Именно поэтому такие методы как shift и unshift в реальной практике очень редко используются

Нам необходимо перебрать эти элеметы внутри массива, можем использовать как обычный цикл, так и специальный цикл перебора массива

const arr1 = [10, 20, 30, 40, 50, 60, 70];
Обычный цикл

for( let i = 0; i < arr1.length; i++) {
    Этот цикл будет отрабатывать до тех пор, пока не закончаться элементы в массиве

  console.log(arr1[i]);

    Это если мы бы обращались arr1[0] arr1[1] arr[2]
}

Конструкция перебора для массива for of

for (let value in arr1) {
  console.log(`свойство ${value} и его значение ${arr1[value]}`);
}

Здесь нужно напомнить, когда разбирали обьекты, говорили что мы не могли их перебрать при помощи for of, дело в том что такая конструкция работает с массиво подобными сущностями: массив, строка, псевдомассив и такие сущности как map и set, так же мы можем перебрать какие-то определенные элементы со страницы

const arr2 = ['one', 'two', 'three', 'four'];

arr2.forEach(function(item, i, arr) {

    Помним урок про callck функции, так как метод forEach принимает в себя еще одну функцию(callback), и эта фукнция   будет выполняться каждый раз для каждого элемента массива. Она в себя может принимать 3 аргумета
    1) Тот элемент который мы перебираем 'one', 'two', 'three', 'four'
    2) Номер по порядку 0, 1, 2, 3
    3) Ссылка на тот массив который мы перебираем, в некоторых случаях это тоже необходимо

  console.log(`${i}: ${item} - внутри массива ${arr}`);

    Но есть один нюанс, такой метод мы уже не сможем остановить или пропустить какой-то элемент, так как break и continue тут не сработают, НО В ОБЫЧНОМ ЦИКЛЕ и МЕТОДЕ FOR OF МОЖНО ИСПОЛЬЗОВАТЬ break и continue
});

Методы split, join, sort. И посмотри насчет метода splice

  split  Из строки сделать массив
  const str = prompt('');

От пользователя будем получать какую-то строку, и дальше на основании этой строки, хотим сформировать список товаров

  const products = str.split(', ');

и здесь в split должны указать через какой разделитель, будут товары в строке, к сожалению мы должны это четко знать, это может быть , или ; или - и т.д.
Так как строку мы не можем поменять, поэтому ее нужно сперва поместить в другую пременную, или же сразу же менять строку const str = prompt('').split(, );

  console.log(products);

Получится только с правильным указанным разделителем, в нашем случае запятая пробел, а если разделитель будет отличаться, он просто запишет ее как в строку как тип данных string

const str2 = 'apple, orange, cherry'.split(', ');
console.log(str2);  // [ 'apple', 'orange ', 'cherry' ]

const str3 = 'apple,orange, cherry'.split(', ');
console.log(str3);  // [ 'apple,orange ', 'cherry' ]

join обратная операция когда на основании массива, можем сформировать большую строку, к примеру можем взять список имен и вывести на экран в качестве строк

const str4 = ['Nurike', 'Temur', 'Stas', 'Madi'];
const result = str4.join(' '); // Разделитель пробел
console.log(result);  // Nurike Temur Stas Madi

let someString = 'This is some strange string';
let someArr = someString.split('').reverse().join('');

console.log(someArr); // gnirts egnarts emos si sihT
Смотри тут если split('') join('') записать пустые ковычки, то он каждую букву отдельно отобразит, а если записать ковычки и пробел (' '), то он выведит каждое слово из строки
reverse() - Массив делает задом наперед

Комбинация методов
const test = prompt('Введите товары через запятую и пробел', '');
const products2 = test.split(', '); // яйца, картошка, творог, лимон, хлеб, капуста
const changed = products2.join(' - ');
console.log(changed); // яйца - картошка - творог - лимон - хлеб - капуста, поменяли просто разделитель

sort Метод сортировки

const sortTest = ['bbb', 'ccc', 'aaa'].sort();
console.log(sortTest);  // [ 'aaa', 'bbb', 'ccc' ] и у нас все отсортировалось в алфовитном порядке
console.log(sortTest.join('-'));  // aaa-bbb-ccc

// Но у этого метода есть одна особенность, он всегда сортирует элементы которые находятся внутри массива, как строки, если массив из строчных элементов, то он их спокойно отсортирует по алфавиту, но вы будете удивлены если данный метод применить в массиву с числами

let sortNumber = [2, 1, 4, 3, 5];
sortNumber.sort();
console.log(sortNumber);  // [ 1, 2, 3, 4, 5 ] пока все логично

sortNumber = [1, 2, 3, 4, 10, 23, 13];
sortNumber.sort();
console.log(sortNumber);  // [ 1, 10, 13, 2, 23, 3, 4 ] поучаем такой результат, очень странная сортировка

// Изначально метод sort сортирует все как строки, каждое число которое начинается с 1, встала впереди, причем сравнение шло посимвольно. 1, 10, 13 у этих трех чисел первая 1, так что он равны, потом 0 и 3, 0 будет меньще 3 поэтому 10 встала на второе место, потом идет у нас 13, массив с числами отсортировался как строки, но этого мы можем избежать. Метод sort может принимать в себя callback функцию, мы можем сказать как именно отсортировать этот массив, сейчас мы напишем шаблон который очень часто будет встречаться в таких сортировачных вещах

function compareNum(a, b) {
  return a - b;
}

console.log(sortNumber.sort(compareNum)); // [1, 2, 3, 4, 10, 13, 23] вот теперь числа отсортировались правильно. И возникает вопрос, а как вообще работает эта функация. Дело в том что метод sort внутри себя использет один из алгоритмов, который называется алгоритм быстрой сортировки, это не совсем простая вещь и на практике она не особо нужна, просто запомни эту фукнцию и используй, но для того чтобы углубится в знание алгоритмов, стоит ознакомится с данным алгоритмом по ссылке в уроке

Частный случай обьектов. МАССИВЫ
// Чтобы создать копию массива, мы конечно же можем так же воспользоваться каким-то там циклом, написать функцию для этого, но так же есть и метод чтоб создать копию массива

const oldArray = ['a', 'b', 'c'];
// const newArray = oldArray;
// Если вот так оставим структуру, то в newArray просто передастся ссылка на oldArray

const newArray = oldArray.slice();

// Этот метод который просто позволяет скопировать старый массив, в него еще можно передать аргументы по кол-во этих элементов

newArray[1] = 'asdsdsdsd';
console.log(oldArray);  // [ 'a', 'b', 'c' ]
console.log(newArray);  // [ 'a', 'asdsdsdsd', 'c',]

SPREAD оператор, оператор разворота

const video = ['youtube', 'vimeo', 'rutube'],
      blogs = ['wordpress', 'livejournal', 'blogger'],
      internet = [...video, ...blogs, 'vk', 'facebook'];  // Такой синтаксис позволит нам просто вытащить эти элементы, которые будут через запятую, и они все будут помещаться в переменную internet, и добавили свои какие-то данные
console.log(internet);  // ['youtube','vimeo','rutube','wordpress','livejournal','blogger','vk','facebook']
// Оператор разворота просто развернул эти структуры на отдельные элементы


function log(a, b, c) {
  console.log(a);
  console.log(b);
  console.log(c);
}

const num = [2, 5, 7]; 
// Допустим этот массив к нам пришел с сервера, то есть он сформировался где-то на стороннем ресурсе и он нам пришел в таком виде. Представь что вместо этих цифр могут прийти данные о каком-то видео: ссылка на сам источник, ссылка на заглушку(картинка), ссылка на автора. И все эти три аргумента нам необходимо передать в функцию log, но как это сделать, ведь функция принимает три отдельных элемента, она не принимает массив и здесь нам идет на помощь spread оператор
log(num[0], num[1], num[2]); // 2 5 7
// Но вместо того чтоб передать три аргумента
log(...num);  // 2 5 7
// Теперь этот массив просто разложится на три отдельных элемента, и эта функция запустится уже с этими тримя элементами. Вот с такой конструкцией будем работать часто, особенно во второй части курса, там где будем использовать библеотеку React


Создаем поверхностную копию массива и обьекта с помощью spread оператора
//Массив
const array = ['a', 'b'];
const newArray2 = [...array];

newArray2.push('c');
console.log(array);
console.log(newArray2); 
const {border, bg} = options.colors;

Мы деструктуризировали обьект, разбили на более мелкие удобные кусочки. Вытащили эти свойства border и bg которые находятся во вложенном обьекте в качестве отдельных ПЕРЕМЕННЫХ. Да понятное дело что сейчас это не особо как то применимо в такой маленькой вложенности, но в будущем когда будет 5 обьектов вложенных в друг друга, и тогда намного удобнее будет вот так разделять, иначе придеться прописывать options['colors']['border]['bla']['yo']['и т.д.']

console.log(border);  // black
console.log(bg);  // red

Это как раз что мы хотели, и это значит что деструктуризация удалась


