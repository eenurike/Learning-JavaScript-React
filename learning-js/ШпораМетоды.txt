СТРОКИ

const str = 'test';

console.log(str.length);  // 4, это кол-во символов внутри строки и это часто используемое свойство для того чтоб получить длину как строки, так и других типов данных
const arr = [1, 2, 3];

console.log(arr.length);  // 3, 3 элемента внутри массива
Обрати внимание что когда используем СВОЙСТВА, мы его никак не вызываем, оно просто пишется через точку, а методы которые будут вспомогательными функциями, они уже будут вызываться с помощью круглых скобок

В самом браузере можно посмотреть все методы кого-то элемента, например тип данных Number. В браузере в консоле пишем console.dir(Number);

console.log(str[2]); // s, Получили третью букву из нашей строки, в реальных задачах такой подход используется довольно редко, новечьки допускают частую ошибку делаю вот так
console.log(str[2] = 'd');
Тоесть получили какой-то символ и пытаются его поменять
console.log(str); 
Но мы не получили желаемого результата tedt, а получили прежнее значение test. Строку мы напрямую поменять не можем, для этого есть методы

console.log(str.toUpperCase()); // TEST, меняет строку на верхний регистр, мы выполнели какое-то действие над строкой
console.log(str); // test, но предыдущее значение не поменялось
Дело в том что str.toUpperCase() оно возвращает новое значение, оно напрямую не меняет ту строку которая была там, а уже это новое значение может где использовать, записать в консоль или засунуть в другую переменную и т.д. А наш исходник не меняется

const strLower = 'teSt';
console.log(strLower.toLowerCase()); // test
Превращает строку в нижний регистр. Такое в практике довольно часто бывает, когда например пользователь вводит какие-то данные на сайте, он может по ошибке написать какую-то букву с большой буквы, и когда мы уже будем обрабатывать эти данные, мы будем превращать все в нижний регистр

console.log(fruit.indexOf('fruit'));  // 5, Тоесть слово fruit у нас наченается с 4-го индекса. Этот метод должен уже принимает в себя какой-то аргумент. Самое очевидное использование этого метода для того чтобы увидеть что этот кусочек дествительно существует, но иногда этот метод используется для того чтобы определить, а действительно ли в этой строке есть искомое значение
console.log(fruit.indexOf('q'));  // -1, Так как такой буквы нет в нашей строке

const logg = 'Hello World';
console.log(logg.slice(6, 11));  // World, Вырезали слово world из нашей строки, у этого метода первый аргумент это с какой части строки будем возвращать что-то, второй аргумент это где заканчивать вырезание строки. Так по логике должно было быть 10 а не 11, дело в том что не включая 10 букву
console.log(logg.slice(6));  // World, Если один аргумент, то вырезается с указаного начала и до конца

console.log(logg.substring(6, 11)); 
Он похож на slice, но только первый метод может быть больше второго (но не стоит так делать), и он не поддерживает отрицательные значения. Решай сам какой из способов использовать, просто помни такие не большие особенности

console.log(logg.substr(6, 5));
Этот метод вторым аргументом говорит сколько символов вырезать 

console.log(logg.trim());
Метод trim уберает пробелы вконце и вначале строки, а если все пробелы то возвращает пустую строку, могли бы записать следующей строкой a.trim(), но зачем когда можно сразу сделать. Не учли то что пользователь может ввести пробелы. Область применения этого метода сводится не только к работе с данными, который ввел пользователь, хотя чаще всего это и есть его основная задача, так же вам могут приходить некоректные данные от сервера или пробелы случайно будут попадать в строку при выполнения некоторых функций

ЧИСЛА

Для работы с числами в JS есть мини билиотека в самом браузере. В консоле пишим Math. и дальше выпадает список из всех методов (синусы, косинусы, максимальное значение, минимвльное значение и т.д.) остановимся на округлении 

const num = 12.2;
console.log(Math.round(num)); // 12, округляет до ближайшего целого числа
В практической дефтельности довольно редко придется работать с чем-то кроме округления. Такие функции как синусы, косинусы в вебе они довольно редко используются

const test = '12.2px';  
Допустим очень такой распространенный случай когда мы получаем такое значение со страницы, это размеры определенного элемента
console.log(parseInt(test));  // 12 причем это уже числовой тип данных, На самом деле этот метод который вызывается на числах Number.parseInt(), но для удобства разработчики вынесли его в отдельную глобальную функцию которую мы просто можем вот так вызывать. parseInt занимается тем что переводит число в другую систему исчесления: есть десятичная система исчиления (1,2,3,4 и т.д.), двоичная (0.1, 0.2, 3.5), но на самом деле есть много различных таких систем

console.log(parseFloat(test)); // 12.2 он возвращает значение с плавающей точкой(то есть с дробными значениями), этот метод изначально служит для того чтобы взять какое-то число либо строку и вернуть нам в десятичном варианте

ОБЬЕКТЫ

const options = {
  name: 'test',
  width: 1024,
  height: 1024,
  colors: {
    border: 'black',
    bg: 'red'
  }
};

Если нужно удалить какое-то значение нужно использовать специальный оператор

delete options.width;

console.log(options);
Удалили свойство width, но если нужно удалить сразу несколько обьектов нужно запускать цикл, который будет на какие-то параметры ориентироваться и удалять определенные свойтсва

Иногда нам нужно перебрать обьект
for (let key in options) {
  Это цикл будет работать столько раз, сколько свойств находится внутри этого обьекта, и переменная key обращается именно к ключам обьекта
  // console.log(`Свойство ${key} имеет значение ${options.key}`);
  console.log(`Свойство ${key} и его значение ${options[key]}`);
}

Заметь если обращаться через точку ${options.key}, то мы почему-то получаем результат 'Свойство width имеет значение undefined, но если записать ${options[key]}, то все нормально
Очень интересный момент, что вложенный обьект консоль вывел нам как "Свойство colors и его значение [object Object]", это все потому что мы все значение выводим в качестве строк, и когда цикл натыкается на вложенные обьект, он его не может переобразовать в строку, и он просто передает строковое предствавление обьекта, консоль не выдает ошибку, консоль просто говорит что это обьект который он не может обьект превратить в строку

for (let key in options) {
  console.log(typeof(options[key]));
}
Видим что одно из значений является обьектом

for (let key in options) {
  if (typeof(options[key]) === 'object') {
    То есть мы проверяем, если по типу данных значение будет object, то запускаем еще один перебор
    for (let i in options[key]) {
      // Как бы key отвечает за основной обьект а i вложенный обьект, и мы перебираем свойства(i) у вложеного обьекта(key)
      console.log(`Свойство вложеного обьекта ${i} и его значение ${options[key][i]}`);
      // options[key] это мы перебираем обьект options, и то что бы достучаться до значения в обьекте colors мы можем использовать двойные options[key][i]. Это как бы если мы обратились options['colors']['border]
    }
  } else {
    console.log(`Свойство обьекта ${key} и его значение ${options[key]}`);
  }
}

Кстати у обьекта нет свойства length, и это очень интересная задача, потому что там используется прием счетчика, и это очень чатсый прием на первых порах
let counter = 0;

for (let key in options) {
  counter++;
}
То есть счетчик пробегается по каждому свойству и увеличивает счетчик
console.log(counter); // 4, но без свойств во вложенном обьекте

counter = 0;
for (let key in options) {
  if (typeof(options[key]) === 'object') {
    for (let i in options[key]) {
      counter++;
    }
  }
  counter++;
}

console.log(counter); // 6 Это уже со свойствами во вложенном обьекте

Но этот способ не совсем удобнен, и тут мы знакомимся с методом для обьекта
console.log(Object.keys(options)); // [ 'name', 'width', 'height', 'colors' ]
Этот метод берет наш обьект и на его основании создает массив в котором все элементы это ключи, ну и мы уже знаем как можно подсчитать кол-во значений в массиве
console.log(Object.keys(options).length); // 4
console.log(Object.keys(options).length + Object.keys(options.colors).length);  // 6 с вложенными свойствами

Таких методов у Object много, будем проходить их в течении курса. Но и такие методы мы можем создавать вручную, помним что методы это дейсвия которые может делать наш обьект

const options2 = {
  name: 'test',
  width: 1024,
  height: 1024,
  colors: {
    border: 'black',
    bg: 'red'
  },
  makeTest: function() {
    console.log('  test  '.toUpperCase().trim());
    Вот и наш собственный метод который будет работать внутри options. Это тоже самое что и когда мы прописывали Object.keys(options) именно .keys() это и есть метод, только эти методы уже встроены в JS, а эти мы создаем сами. И помни что в таком состоянии наш метод просто существует, а потом его нужно запустить(вызвать)
  }
};

options2.makeTest();  // запускаем(вызываем) наш метод и получаем 'TEST' без пробелов и в верхнем регистре