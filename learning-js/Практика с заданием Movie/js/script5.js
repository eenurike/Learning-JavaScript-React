'use sctrict';

// Загрузка на страницу
/*
Казалось бы в чем проблема подключить скрипт, просто
в конец HTML структуры пихай и все, но а если DOM структура 
на тысячи и тысячи строк код, и пользователь что будет сидеть
и ждать прогрузку HTML чтобы нажать на кнопку. И тут существуют
такие атрибуты для <script> как defer и async
*/

// Без DOMContentLoaded для тестов
const p = document.querySelectorAll('p');
console.log(p);
/*
1) defer
И видим что наши элементы, хотя подключили скрипт до HTML структуры.
А если бы не прописали атрибут defer, то у нас бы сперва прогрузился
скрипт, а потом DOM структура, и мы не получили наши элементы,
в нашем случае вывелся пустой псевдомассив.
Этот атрибут сообщает браузеру что он должен продолжать обрабатывать
страницу, и загружать этот скрипт в фоновом режиме, а затем запустить
этот скрипт когда он загрузится.
1) скрипты с defer никогда не блокируют страницу
2) скрипты с таким атрибутом всегда выполняются когда наша 
DOM дерево уже готово. Такие скрипты они будут дожидаться полной
готовности нашей верстки. Но они срабатывают до события DOMContentLoaded,
это не особо важно для практики, но надо знаять. Так что этот скрипт 
можно поместить в head.
Для теста подключили еще один скриптовый файл test5.js, там всего
одна строка кода, и как бы он должен подключится первее чем script5.js
где боьше кода, хотя test5.js стоит перед script5.js. Но с помощью 
атрибута defer, скрипты будут подключатсья последовательно, сперва
выполнится script5.js потом test5.js.
Так соблюдается порядок выполнения всех подключаемых утилит и мы
точно уверены что страница готова. Значит мы можем подключить
библеотеку с полезными утилитами(JQuery) а следующим наш скрипт,
который использует возможности этой библеотеки и зависит от нее,
при этом вся наша страница не блокируется, пока это все загружается 
паралельно ей. Но с практической точки зрения в реальных проектах
такие программы как google speed test и т.д. будут ругаться на то что
наши скрипты подключены в head, но они все равно будут работать. 
Поэтому defer не всегда актуален 

2) async
*/