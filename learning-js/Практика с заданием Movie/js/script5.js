'use sctrict';

// Загрузка на страницу
/*
Казалось бы в чем проблема подключить скрипт, просто
в конец HTML структуры пихай и все, но а если DOM структура 
на тысячи и тысячи строк код, и пользователь что будет сидеть
и ждать прогрузку HTML чтобы нажать на кнопку. И тут существуют
такие атрибуты для <script> как defer и async
*/

// Без DOMContentLoaded для тестов
const p = document.querySelectorAll('p');
console.log(p);
/*
1) defer
И видим что наши элементы, хотя подключили скрипт до HTML структуры.
А если бы не прописали атрибут defer, то у нас бы сперва прогрузился
скрипт, а потом DOM структура, и мы не получили наши элементы,
в нашем случае вывелся пустой псевдомассив.
Этот атрибут сообщает браузеру что он должен продолжать обрабатывать
страницу, и загружать этот скрипт в фоновом режиме, а затем запустить
этот скрипт когда он загрузится.
1) скрипты с defer никогда не блокируют страницу
2) скрипты с таким атрибутом всегда выполняются когда наша 
DOM дерево уже готово. Такие скрипты они будут дожидаться полной
готовности нашей верстки. Но они срабатывают до события DOMContentLoaded,
это не особо важно для практики, но надо знаять. Так что этот скрипт 
можно поместить в head.
Для теста подключили еще один скриптовый файл test5.js, там всего
одна строка кода, и как бы он должен подключится первее чем script5.js
где боьше кода, хотя test5.js стоит перед script5.js. Но с помощью 
атрибута defer, скрипты будут подключатсья последовательно, сперва
выполнится script5.js потом test5.js.
Так соблюдается порядок выполнения всех подключаемых утилит и мы
точно уверены что страница готова. Значит мы можем подключить
библеотеку с полезными утилитами(JQuery) а следующим наш скрипт,
который использует возможности этой библеотеки и зависит от нее,
при этом вся наша страница не блокируется, пока это все загружается 
паралельно ей. Но с практической точки зрения в реальных проектах
такие программы как google speed test и т.д. будут ругаться на то что
наши скрипты подключены в head, но они все равно будут работать. 
Поэтому defer не всегда актуален 

2) async

1. Страницы у нас не ждет асинхронных скриптов, содержимое просто
обрабатывается и отображается 
2. Событие DOMContentLoaded и асинхронные скрипты не ждут друг-друга
Если мы ставим атрибут async, то этот скрипт начинает загружаться
как только до него доходит страница, он загружаеться в фоновом режиме,
но при этом запускаеться как только он был загружен, он вообще никого не ждет.
И тут 3-ья особенность, то что остальные скрипты не ждут async, и скрипты
с async не ждут другие скрипты, то есть они становятся обсолютно независимыми.
И в нашем примере мы не знаем какой скрипт запуститься первый, который загрузился
первый, тот и запустится. Но тут закрадывается мысль, а зачем нам нужно такое 
поведение, дело в том что иногда мы будем подключать различные стороние скрипты,
которые не особо подвязаны как под DOM структуру, так и под другую какуюто 
функциональность(метрики и счетчики), им главное уловить что пользователь зашел
на сайт.
В итоги когда используем скрипты с атрибутом async, мы должны быть точно уверены,
что этот скрипт абсолютно не зависит от DOM структуры, ему все равно сформировалась
она или нет, и кроме этого он должен не зависить от других скриптов, он загрузился
и сразу выполнился  

3) Подключаем прям в файле js
*/

//const script = document.createElement('script');
//script.src = "js/test5.js";  // Установили атрибут с путем src
//document.body.append(script);   // Помещаем скрипт в конец body

/*
Этот скрипт начнет загружаться только после того, как он будет добавлен в документ,
только выполнения кода на строке 70.
Динамически загружаемые скрипты по умолчанию видут себя как async, они
никого ждать не будут, скрипт который загрузился здесь первым, так и будет
загружаться первым, а если нужно чтоб скрипт вел себя как обычно пишем
script.async = false
document.body.append(script);
Но чтоб контролировать порядок подключения скриптов
*/

function loadScript(src) {
    const script = document.createElement('script');
    script.src = src;
    script.asycn = false;
    document.doby.append(script);
}

loadScript("js/test5.js");
loadScript("js/some5.js");
/*
Такое динамическое формирования скриптов это давольно
не редкое занятие 
*/