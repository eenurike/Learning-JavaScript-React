'use strict';

// СОБЫТИЕ И ИХ ОБРАБОТЧИКИ

/*
Это один важнейших тем в JS. Ведь у нас почти все
строится на взаимодейтвии с элементами, и все какие то
технологии, все какие-то скрипты в будущем, они все 
будут опираться на событийную систему, ведь как не крути
мы создаем продукт для пользователей.
Событие это сигнал от браузера что, что то у нас
произошло (клик, двойной клик, наведение мыши, удрать мышь
с элемента, прокрутка колесика, нажать отправка данных
формы, нажатие клавишь на клавиатуре и многое другое)
Всем чем пользователь занимается на странице это и есть событие,
и мы их можем отлавливать.
Чтобы использовать событие, мы должны назначить обработчик события. 
Обработчик - это функция которая срабатывает, как только событие 
произошло. Например: если пользователь кликает на кнопку меню,
и срабатывает функция, которая открывает это меню. 
Есть 3 способа назначить обработчик события  
*/

// 1) Использовать HTML атрибут 

/*
<button onclick="alert('YO')">Click me</button>
Но такой способ никогда не используется в реальных проектах
*/

// 2) Использовать свойства DOM дерева для событий 

let btn = document.querySelector("button");

// btn.onclick = function() {
//     alert("Clicked");
// };

/*
И происходит тоже самое, выводится алерт 
Но такой способ тоже практический не используется, и есть причина
*/

// btn.onclick = function() {
//     alert("second click");
// };

/*
Как бы вполне логично, второй клик перетер первый, но такое поведение 
не допустимо, а что если после первого клика, поменялись данные, и
по второму клику отправилась форма. 
И еще один минус что нам иногда нужно будет удалять обработчики событий,
таким способ удалить уже не получиться
*/

// 3) addEventListener и removeEventListener самый рабочий способ

// btn.addEventListener('click', () => {        
//     alert("clicked");
// });

/*
btn добывляем слежку за событиями, первым аргументом задаем
название события, вторым аргументом запускаем callback функцию, которая
и будет нашим обработчиком. Только строго после клика, в действие
вступит наша функция. 
Или в более класическом виде
    btn.addEventListener('click', function() {
        alert("clicked");
    }); 
*/

// btn.addEventListener('click', () => {        
//     alert("second click");
// });

/*
И большой плюс этого способа что можно назначать несколько 
событий на один элемент. 
Видим что при клике, обработалась первое событие,
а потом второе. 
Еще не обходимо знать что событие в JS выполняются 
в порядке очереди, как поступило новое событие, оно 
добавляется в очередь не зависимо от других событий   
*/

btn.addEventListener('mouseenter', () => {
    console.log("Hover");
});
/*
Работает как hover, и заметь тут другой аргумент события
наводим мышкой на элемент, и сработал обработчик, а те
два других обработчика не сработали, так как мы пока не кликнули
на элемент, а просто навели
*/

// Важная информация
/*
Иногда нам нужно получать данные о том элементе, с которым
мы взаимодействуем (что за событие произошло, или что за элемент
используется,или координаты этого элемента и т.д.)
Для этого есть специальный обьект, который называется event,
и как любой обьект в JS он может иметь свои свойства, и он 
передается как аргумент в callback функцию. Называть можно
как угодно, но обычно event или просто e, а если нужны какие-то
свои аргументы, то записывать нужно строго после event, так 
как event зарезервирован в первом аргументе 
*/
btn.addEventListener('mouseenter', (event) => {
    console.log(event);
});
/*
И получаем обьект MouseEvent, это как раз обьект описывает что
произошло с элементом. Одни из важных свойств это type, это
тот события который произошел. targer это тот элемент, на котором 
произошло событие, и эти свойства очень часто будем использовать
*/
// btn.addEventListener('mouseenter', (event) => {
//     console.log(event.target);
// });
/*
И видим какая именно кнопка, ну пока мы вывели одну кнопку,
но в дальнейшем ведь будем обрабатывать много элементов,
и нужно знать на каком конкретно элементе произошло
событие в данный момент. 
И тут перед нами открывается куча возможностей, ведь теперь
можем отслеживать элемент, и менять его как то стилями, меня классы
или просто удалить его со страницы!
*/

// btn.addEventListener('click', (event) => {   КАК ЗАКОНЧИШЬ УРОК РАЗКОМЕНТИРУЙ ЭТОТ КОД
//     event.target.remove();                   
// });                                          

// Удаляем обработчики событий 
/*
Но тут загвостка в том что мы должны использовать точно
такую же функцию, которую мы назначали при помощи addEventListener
Помнишь задачку, равны ли два массива которые одинаковы по 
своим внутреностям
    btn.addEventListener('click', (event) => {
        console.log(event.target);
    });
    btn.removeEventListener('click', (event) => {
        console.log(event.target);
    });
так вот, если мы два раза напишем такую функцию, 
это не одна и та же функция. Поэтому чтобы удалить обработчик
нужно эту функцию вынести в отдельную переменную
*/
let deleteElement = (event) => {
    console.log(event.target);
};
/*
Если бы назвали просто delete, была бы ошибка
так как это зарезервированное слово
*/

btn.addEventListener('click', deleteElement);
btn.removeEventListener('click', deleteElement);
/*
Ничего не произойдет, так как сперва назначили обработчик
потом удалили этот же обработчик. 
И помним что не вызываем функцию, мы ссылаемся на функцию
которая вызывается на let deleteElement.
Обычно удаляются обработчки через условие, когда что-то
произошло и обработчик уже не нужен
*/
let i = 0;
let deleteElementSecond = (event) => {
    console.log(event.target);
    i++;
    if (i == 1) {
        btn.removeEventListener('click', deleteElementSecond);
    }
};

btn.addEventListener('click', deleteElementSecond);
/*
И видим что когда, наша i равна одному, у нас удаляется обработчик
и если будем кликать дальше по эелементу, у этого элемента уже не будет
никакого обработчика
*/

// Всплытие событий, это НЕ всплытие переменных(hoisting)

let overlay = document.querySelector('.overlay');
/*
HTML структура такова
	<div class="overlay">
		<button id="btn">Нажми меня</button>
	</div>
*/
let overlayFunck = (event) => {
    console.log(event.target);
    console.log(event.type);
};

btn.addEventListener('click', overlayFunck);
overlay.addEventListener('click', overlayFunck);
/*
Когда у нас есть два элемента, один из них родителем другого,
но при этом на них назначены одработчики событий, которые
обрабатывают одни и те же действия(клик).
В нашем примере видим что событие сперва сработало на том элементе
который идет вложенее, и потом идет по иерархии вверх и событие
сработало на родителе(overlay), это и называется всплытие 
событий, когда данное действие срабатывает сперва на вложеном
и после этого поднимается наверх по иерархии нашего DOM дерева.
И когда у нас в консоле выводится event.target, мы ссылаемся на
эелемент на котором произошло изначально событие 
*/
let currentFunck = (event) => {
    console.log(event.currentTarget);
    console.log(event.type);
};

btn.addEventListener('click', currentFunck);
overlay.addEventListener('click', currentFunck);
/*
С помощью currentTarget очетливо видно как событие всплывает наверх,
сперва нажат был вложенный элемент, а потом его родитель(overlay).
И это ключевая разница между event.target и event.currentTarget
Но на практике чаще будем пользоваться event.target
Всплытие событий - это когда обработчик события сначала срабатывает на
самом вложенном элементе, затем на родителе(если он у него есть), и
так выше и выше поднимаясь по иерархии
*/

// Отменяем стандартное поведение в браузере
/*
Если кликнуть по ссылке на странице, мы перейдем по этой ссылке,
это стандартное поведение ссылки, и если нажимаем на кнопку в форме
у которой стоит атрибут submit, и мы отправляем данные на сервер или
можно выделять текс чтобы копировать, все это стандартное 
поведение браузера
*/
const link = document.querySelector("a");
link.addEventListener('click', (event) => {
    event.preventDefault();
    console.log(event.target);
});
/*
И у event есть метод preventDefault, который и отменяет
стандартное поведение браузера, помним что методы нужно вызывать
и теперь ссылка никуда не перенапровляет, вместо этого
он выводит что мы ему сказали. Такое поведение мы будем часто
использовать
*/

/*
Ну и навешиваем обрабочик события на несколько элементов
    let btns = document.querySelectorAll('button');
    btns.forEach(btn => {
        btn.addEventListener('click', (event) => {
            console.log(event.target);
        });
    });
*/

/*
Ну и третим аргументом в eventListener можем передать options
посмотри в документации, есть интересное свойство как once
то есть использовать событие всего раз, вместо removeEventListener
    btns.forEach(btn => {
        btn.addEventListener('click', (event) => {
            console.log(event.target);
        }, {once:true});
    });
но не значит что вообще игнорируем removeEventListener, он полезен
вместе с условиями, когда чтото произошло удаляется обработчик события
*/
