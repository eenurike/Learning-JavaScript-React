'use strict';

// СОБЫТИЕ И ИХ ОБРАБОТЧИКИ

/*
Это один важнейших тем в JS. Ведь у нас почти все
строится на взаимодейтвии с элементами, и все какие то
технологии, все какие-то скрипты в будущем, они все 
будут опираться на событийную систему, ведь как не крути
мы создаем продукт для пользователей.
Событие это сигнал от браузера что, что то у нас
произошло (клик, двойной клик, наведение мыши, удрать мышь
с элемента, прокрутка колесика, нажать отправка данных
формы, нажатие клавишь на клавиатуре и многое другое)
Всем чем пользователь занимается на странице это и есть событие,
и мы их можем отлавливать.
Чтобы использовать событие, мы должны назначить обработчик события. 
Обработчик - это функция которая срабатывает, как только событие 
произошло. Например: если пользователь кликает на кнопку меню,
и срабатывает функция, которая открывает это меню. 
Есть 3 способа назначить обработчик события  
*/

// 1) Использовать HTML атрибут 

/*
<button onclick="alert('YO')">Click me</button>
Но такой способ никогда не используется в реальных проектах
*/

// 2) Использовать свойства DOM дерева для событий 

let btn = document.querySelector("button");

// btn.onclick = function() {
//     alert("Clicked");
// };

/*
И происходит тоже самое, выводится алерт 
Но такой способ тоже практический не используется, и есть причина
*/

// btn.onclick = function() {
//     alert("second click");
// };

/*
Как бы вполне логично, второй клик перетер первый, но такое поведение 
не допустимо, а что если после первого клика, поменялись данные, и
по второму клику отправилась форма. 
И еще один минус что нам иногда нужно будет удалять обработчики событий,
таким способ удалить уже не получиться
*/

// 3) addEventListener и removeEventListener самый рабочий способ

btn.addEventListener('click', () => {        
    alert("clicked");
});
/*
btn добывляем слежку за событиями, первым аргументом задаем
название события, вторым аргументом запускаем callback функцию, которая
и будет нашим обработчиком. Только строго после клика, в действие
вступит наша функция. 
Или в более класическом виде
    btn.addEventListener('click', function() {
        alert("clicked");
    }); 
*/
btn.addEventListener('click', () => {        
    alert("second click");
});
/*
И большой плюс этого способа что можно назначать несколько 
событий на один элемент. 
Видим что при клике, обработалась первое событие,
а потом второе. 
Еще не обходимо знать что событие в JS выполняются 
в порядке очереди, как поступило новое событие, оно 
добавляется в очередь не зависимо от других событий   
*/

btn.addEventListener('mouseenter', () => {
    console.log("Hover");
});
/*
Работает как hover, и заметь тут другой аргумент события
наводим мышкой на элемент, и сработал обработчик, а те
два других обработчика не сработали, так как мы пока не кликнули
на элемент, а просто навели
*/

// Важная информация
/*
Иногда нам нужно получать данные о том элементе, с которым
мы взаимодействуем (что за событие произошло, или что за элемент
используется,или координаты этого элемента и т.д.)
Для этого есть специальный обьект, который называется event,
и как любой обьект в JS он может иметь свои свойства, и он 
передается как аргумент в callback функцию. Называть можно
как угодно, но обычно event или просто e, а если нужны какие-то
свои аргументы, то записывать нужно строго после event, так 
как event зарезервирован в первом аргументе 
*/
btn.addEventListener('mouseenter', (event) => {
    console.log(event);
});
/*
И получаем обьект MouseEvent, это как раз обьект описывает что
произошло с элементом. Одни из важных свойств это type, это
тот события который произошел. targer это тот элемент, на котором 
произошло событие, и эти свойства очень часто будем использовать
*/
// btn.addEventListener('mouseenter', (event) => {
//     console.log(event.target);
// });
/*
И видим какая именно кнопка, ну пока мы вывели одну кнопку,
но в дальнейшем ведь будем обрабатывать много элементов,
и нужно знать на каком конкретно элементе произошло
событие в данный момент. 
И тут перед нами открывается куча возможностей, ведь теперь
можем отслеживать элемент, и менять его как то стилями, меня классы
или просто удалить его со страницы!
*/

// btn.addEventListener('click', (event) => {   КАК ЗАКОНЧИШЬ УРОК РАЗКОМЕНТИРУЙ ЭТОТ КОД
//     event.target.remove();                   
// });                                          

// Удаляем обработчики событий 
/*
Но тут загвостка в том что мы должны использовать точно
такую же функцию, которую мы назначали при помощи addEventListener
Помнишь задачку, равны ли два массива которые одинаковы по 
своим внутреностям
    btn.addEventListener('click', (event) => {
        console.log(event.target);
    });
    btn.removeEventListener('click', (event) => {
        console.log(event.target);
    });
так вот, если мы два раза напишем такую функцию, 
это не одна и та же функция. Поэтому чтобы удалить обработчик
нужно эту функцию вынести в отдельную переменную
*/
let deleteElement = (event) => {
    console.log(event.target);
};
/*
Если бы назвали просто delete, была бы ошибка
так как это зарезервированное слово
*/

btn.addEventListener('click', deleteElement);           
btn.removeEventListener('click', deleteElement);
/*
Ничего не произойдет, так как сперва назначили обработчик
потом удалили этот же обработчик. 
И помним что не вызываем функцию, мы ссылаемся на функцию
которая вызывается на let deleteElement.
Обычно удаляются обработчки через условие, когда что-то
произошло и обработчик уже не нужен
*/
let i = 0;
let deleteElementSecond = (event) => {
    console.log(event.target);
    i++;
    if (i == 1) {
        btn.removeEventListener('click', deleteElementSecond);
    } 
};

btn.addEventListener('click', deleteElementSecond);
/*
И видим что когда, наша i равна одному, у нас удаляется обработчик
и если будем кликать дальше по эелементу, у этого элемента уже не будет
никакого обработчика
*/

