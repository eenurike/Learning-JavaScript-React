Хойстинг - это всплытие переменных
  console.log(name);
  var name = 'Nurike'
Получили результат undefined, получили какой-то результат, хотя это не правильное поведение, по идеи мы должны получить ошибку
  let name = 'Nurike'
  console.log(name);
Тут переменная создается только после ее обьявления  

И всегда лучше создать новую переменную чем перезаписывать много раз одну и туже 
--------------------------------------------------------------------------------------------------------------------
На данный момент существует 8 типов данных. И эти типы данных можем разделить на две категории
1) Простые типы (Примитивы)
   Числа 1,2,3
   Строки 'string'
   Логичкский тип данных true/fasle
   null (когда чего-то просто не существует)
   undefined (когда существует но значения нет), например стоит холодильник, но он пустой
   Symbol 
   BigInt тип данных который отображает большие числа, в JS есть небольшое ограничение при работе с большими числами, мы не можем задать число которое будет больше чем 2 в 53 степени, на практике бывают ситуации когда нам необходимо работать с большими числами
2) Комплексные (Обьекты)
   Массивы []
   Функции function
   Обьекты Даты
   Регулярные выражения
   Ошибки

const person = {
  ключ: значения      Ключ-свойство обьекта: значение этого свойства
  name: 'John',       Тип данных string
  age: 25,            Тип данных number
  isMarried: false,   Тип данных boolean
  sayHello: function() {}
    И function это действия этого персонажа, то есть метод этого обьекта
};

console.log(person.name);     John, то есть через точку мы обратились к значению свойства name
console.log(person[age]);     Ошибка, так как мы используем какуюто перемеенную age которой не существует
console.log(person["age"]);   25, такой способ тоже работает, но JsHint говорит что лучше писать через точку   

const object = {
  'Anna': 500,
  Alice: 800
};
Тут есть четкое соотношение, у нас есть какйто сотрудник и его ЗП, то есть идет пара ключ значение. В массив так записать не получится, мы потеряем смысл, не очень будет понятно что к чему относится. Обрати внимание что свойства в обьектах это строки и мы их можем записывать в двух форматах, можно прописывать в ковычках тогда сразу будет понятно что это строка, можно и записывать и без ковычек, обьект сам поймет что это строка

И почему же массивы это частный случай обьектов
const array2 = ['a', 'b', 'c'];
const arrayObj = {
  0: 'a',
  1: 'b',
  2: 'c',
  a: 'ale'
};
Если посмотреть вглубь массивов, то это те же обьекты, просто у них ключ это всегда ключ номер по порядку
  console.log(arrayObj.0); Получаем ошибку, так как такой синтаксис не очень понятен для JS, мы используем цифру после точки это не совсем правильно
console.log(arrayObj.a);  ale, другое дело когда мы обращаемся к строке а не к числу. Это просто пример, никто в реальной жизни не называет цифрами свойства, но когда-то можно попасть на такой момент, и выход из ситуации есть
console.log(arrayObj['0']);   a, такой способ позволяет избегать ошибок. Поэтому если вдруг будут не предвиденные обстоятельства с обьектами, то всегда надежнее использовать квадратные скобки, они работают нормально и с цифрами которые могут попасть в обьект, или если попадется кирилица или вообще какойто другой язык, и в таких ситуациях будет надежным использовать квадратные скобки

const b = 'Hello';
arrayObj[b] = 'World';  Именно так обратились к [переменной]

console.log(arrayObj); 
{
  0: 'a',
  1: 'b',
  2: 'c',
  a: 'ale',
  Hello: 'World'
}
Видим что мы через переменную добавили новое значение и его свойство
--------------------------------------------------------------------------------------------------------------------
ВАЖНО!!! Вся информация которая приходит от пользователя будет ввиде строк, вне зависимости от того как мы ее получили: с confirm, prompt или с какогото элемента на странице

Хотелось бы эти ответы увидеть на странице, одно из первых команд которая существовала в JS это document.write() В реальных проектах она практически не используется, так как она все содержимое сайта заменяет на то что мы хотим вывести. Это прям такая совсем тестовая команда, которая в реальных проектах не используется
document.write(answers);
--------------------------------------------------------------------------------------------------------------------
Интерполяция

console.log(`https://someurl.com/${category}/4`);
Это формат нового стандарта ES6, используя косые ковычки(бэктики ``), и переменные нужно записывать в ${}. Таким образом мы можем динамически добавлять переменные, ведь они могут прилететь к нам откуда угодно, из базы данных, от ответа пользователя на странице и т.д.
--------------------------------------------------------------------------------------------------------------------
Оператор инкримента и декримента
Они существуют для укорочения нашего кода, и соответственно увеличивают или уменьшают значение на единичку. И довольно частый вопрос на собеседованиях "чем отличается префиксная форма от постфиксной формой"

let incr = 10,
    decr = 10;

decr--;   Оператор декримента, уменьшение на один  (постфиксная форма)
incr++;   Оператор инкремента, увеличение на один (постфиксная форма)

console.log(incr);   11
console.log(decr);   9

incr = 10;
decr = 10;

++incr;   Префиксная форма
--decr;   Постфиксная форма

console.log(incr);    11
console.log(decr);    9
В таких примерах мы конечно не увидим в чем их разница

incr = 10;
decr = 10;

console.log(incr++);  10
console.log(decr--);  10

Числа не изменились, дело в том что когда мы используем инкримент или декримент в постфиксной форме прямо сразу(то есть мы сразу же в console.log изменили и вывели) то есть сразу взяли результат этого оператора, а не операцию инкримента и декримента записали отдельно и отдельно потом вывели переменную. А тут нам сперва возвращается(выводится) старое значение, а потом оператор начинает увеличивать или уменьшать, но число ведь уже вывелось 10, а потом произошла операция инкремента и декримента
console.log(incr);  11
console.log(decr);  9
Тут наглядно видим что в переменную сохранилось уже измененное значение 

incr = 10;
decr = 10;

console.log(++incr);  11
console.log(--decr);  9
А вот тут видим, сперва произошла операция инкремента и декримента а потом число 10 начало меняться, и уже измененное число вывелось
--------------------------------------------------------------------------------------------------------------------
const num2 = 20;

switch(num2) {
В условие помещаем обьект того что мы будем сравнивать и что проверять
  case 19: 
  Тут указываем то значение что мы хотим проверить, и здесь есть очень важный момент, конструкция switch всегда идет на строгое сранение(===) в отличие от обычных условий, то есть switch не сравнивает > < , только сравнивает ===
    console.log('Неверно!'); 
    break;
    Всегда после условия нужно писать break, это обязательная синтаксическая конструкция, она работает так, если num2 = 19, то у нас выполнится case 19; и код пойдет дальше, и на break остановится и не пойдет дальше, если break не было бы, код пошел бы дальше прогонять все case что мы прописали
  case 30:
    console.log('Неверно!');
    break;
  case 22:
    console.log('Верно!');
    break;      
  default:
    Если не один из case не сработал, такое может произойти  
    console.log('Не в этот раз(');
    break;
}    

Есть еще и другой синтаксис при помощи тернарного оператора
const num4 = 30;
(num4 === 30) ? console.log('Ok!') : console.log('Error!');     Ok!
(num4 > 60) ? console.log('Ok!') : console.log('Error!');     Error!
И заметь что использовали два оператора это ? и : , такая запись позволяет нам экономить место и обьем кода. Он называется тернарным оператором потомучто в его работе участвует аж 3 аргумента, это единственным тернарный оператор на данный момент который есть в JS
1. (num > 60)
2. console.log('Ok!')
3. console.log('Error!');

Так же есть бинарный оператор, в его работе участвует 2 аргумента
console.log(4 + 4);
+ это бинарный оператор, потомучто он складывает два аргумента
console.log(+'4');
тут + это унарный плюс, так как он использует всего один аргумент для работы, то есть он меняет тип данных string на number
--------------------------------------------------------------------------------------------------------------------
Логический оператор И(&&),он возвращает правду если все аргументы верны
1. Оператор И(&&) всегда возвращает первое ложное значение если оно есть, на нем он запинается и его возвращает и дальше код уже не идет
2. Если все аргументы верны, код дошел до конца, то возвращает значение последнего аргумента

let a = 0;
let b = 5;
let c = 'Nurike';

if (b && a && c) {
  console.log('yes');
} else {
  console.log('no');
}
// no

console.log(a === 0 && b > 2 && typeof(c) === 'number');  // false, так как условие наткнулось на ложь, и нам вернулось ложь
console.log(b && a && c);   // 0, так как 0 это false. Когда логические операторы работают с данными которые не true/false, они будут возвращать сами значения с которыми они работают,

Запомни что результат логических операций это какое-то логическое булиновое значение

В JS есть 5 сущностей которые будут всегда false 0, ''(' ' это не false, так как это не пустая строка, там есть пробел), null, undefined, NaN. А все остальное всегда будет true

Логический оператор ИЛИ(||), принцип работы похож, но здесь мы проверяем на хотябы одно верное значение. Когда опепратор ИЛИ(||) находит правду он перестает работать и возвращает ту правду на которой он остановился. ИЛИ запинается на правде, но когда все не правда, оператор ИЛИ(||) возвращает последнее ложное значение

Например нам нужно сдать 4 отчета от разных людей
let johnReport, alexReport, samReport, mariaRport = 'done';
И только мария пока предоставила отчет, значит один true есть
console.log(johnReport || alexReport || samReport || mariaRport);
done, Оператор ИЛИ(||) вернул нам первую правду, даже если она стоит вконце этого списка

console.log(!0); // true, 0 у нас false, и оператор НЕ меняет на обратное значение, тоесть true
Здесь никаких хитростей нет, просто обратная операция для того чтобы сказать что-то НЕ, НЕ ПРАВДА, НЕ НЕ ПРАВДА

Приоритеты операторов
|| && !== === != == >= > <= < - + 
Приоритетность идет слева на права, то есть + будет всегда выполнятся первее 
