Хойстинг - это всплытие переменных
  console.log(name);
  var name = 'Nurike'
Получили результат undefined, получили какой-то результат, хотя это не правильное поведение, по идеи мы должны получить ошибку
  let name = 'Nurike'
  console.log(name);
Тут переменная создается только после ее обьявления  

И всегда лучше создать новую переменную чем перезаписывать много раз одну и туже 
--------------------------------------------------------------------------------------------------------------------
На данный момент существует 8 типов данных. И эти типы данных можем разделить на две категории
1) Простые типы (Примитивы)
   Числа 1,2,3
   Строки 'string'
   Логичкский тип данных true/fasle
   null (когда чего-то просто не существует)
   undefined (когда существует но значения нет), например стоит холодильник, но он пустой
   Symbol 
   BigInt тип данных который отображает большие числа, в JS есть небольшое ограничение при работе с большими числами, мы не можем задать число которое будет больше чем 2 в 53 степени, на практике бывают ситуации когда нам необходимо работать с большими числами
2) Комплексные (Обьекты)
   Массивы []
   Функции function
   Обьекты Даты
   Регулярные выражения
   Ошибки

const person = {
  ключ: значения      Ключ-свойство обьекта: значение этого свойства
  name: 'John',       Тип данных string
  age: 25,            Тип данных number
  isMarried: false,   Тип данных boolean
  sayHello: function() {}
    И function это действия этого персонажа, то есть метод этого обьекта
};

console.log(person.name);     John, то есть через точку мы обратились к значению свойства name
console.log(person[age]);     Ошибка, так как мы используем какуюто перемеенную age которой не существует
console.log(person["age"]);   25, такой способ тоже работает, но JsHint говорит что лучше писать через точку   

const object = {
  'Anna': 500,
  Alice: 800
};
Тут есть четкое соотношение, у нас есть какйто сотрудник и его ЗП, то есть идет пара ключ значение. В массив так записать не получится, мы потеряем смысл, не очень будет понятно что к чему относится. Обрати внимание что свойства в обьектах это строки и мы их можем записывать в двух форматах, можно прописывать в ковычках тогда сразу будет понятно что это строка, можно и записывать и без ковычек, обьект сам поймет что это строка

И почему же массивы это частный случай обьектов
const array2 = ['a', 'b', 'c'];
const arrayObj = {
  0: 'a',
  1: 'b',
  2: 'c',
  a: 'ale'
};
Если посмотреть вглубь массивов, то это те же обьекты, просто у них ключ это всегда ключ номер по порядку
  console.log(arrayObj.0); Получаем ошибку, так как такой синтаксис не очень понятен для JS, мы используем цифру после точки это не совсем правильно
console.log(arrayObj.a);  ale, другое дело когда мы обращаемся к строке а не к числу. Это просто пример, никто в реальной жизни не называет цифрами свойства, но когда-то можно попасть на такой момент, и выход из ситуации есть
console.log(arrayObj['0']);   a, такой способ позволяет избегать ошибок. Поэтому если вдруг будут не предвиденные обстоятельства с обьектами, то всегда надежнее использовать квадратные скобки, они работают нормально и с цифрами которые могут попасть в обьект, или если попадется кирилица или вообще какойто другой язык, и в таких ситуациях будет надежным использовать квадратные скобки

const b = 'Hello';
arrayObj[b] = 'World';  Именно так обратились к [переменной]

console.log(arrayObj); 
{
  0: 'a',
  1: 'b',
  2: 'c',
  a: 'ale',
  Hello: 'World'
}
Видим что мы через переменную добавили новое значение и его свойство
--------------------------------------------------------------------------------------------------------------------
ВАЖНО!!! Вся информация которая приходит от пользователя будет ввиде строк, вне зависимости от того как мы ее получили: с confirm, prompt или с какогото элемента на странице

Хотелось бы эти ответы увидеть на странице, одно из первых команд которая существовала в JS это document.write() В реальных проектах она практически не используется, так как она все содержимое сайта заменяет на то что мы хотим вывести. Это прям такая совсем тестовая команда, которая в реальных проектах не используется
document.write(answers);
--------------------------------------------------------------------------------------------------------------------
Интерполяция

console.log(`https://someurl.com/${category}/4`);
Это формат нового стандарта ES6, используя косые ковычки(бэктики ``), и переменные нужно записывать в ${}. Таким образом мы можем динамически добавлять переменные, ведь они могут прилететь к нам откуда угодно, из базы данных, от ответа пользователя на странице и т.д.
--------------------------------------------------------------------------------------------------------------------
Оператор инкримента и декримента
Они существуют для укорочения нашего кода, и соответственно увеличивают или уменьшают значение на единичку. И довольно частый вопрос на собеседованиях "чем отличается префиксная форма от постфиксной формой"

let incr = 10,
    decr = 10;

decr--;   Оператор декримента, уменьшение на один  (постфиксная форма)
incr++;   Оператор инкремента, увеличение на один (постфиксная форма)

console.log(incr);   11
console.log(decr);   9

incr = 10;
decr = 10;

++incr;   Префиксная форма
--decr;   Постфиксная форма

console.log(incr);    11
console.log(decr);    9
В таких примерах мы конечно не увидим в чем их разница

incr = 10;
decr = 10;

console.log(incr++);  10
console.log(decr--);  10

Числа не изменились, дело в том что когда мы используем инкримент или декримент в постфиксной форме прямо сразу(то есть мы сразу же в console.log изменили и вывели) то есть сразу взяли результат этого оператора, а не операцию инкримента и декримента записали отдельно и отдельно потом вывели переменную. А тут нам сперва возвращается(выводится) старое значение, а потом оператор начинает увеличивать или уменьшать, но число ведь уже вывелось 10, а потом произошла операция инкремента и декримента
console.log(incr);  11
console.log(decr);  9
Тут наглядно видим что в переменную сохранилось уже измененное значение 

incr = 10;
decr = 10;

console.log(++incr);  11
console.log(--decr);  9
А вот тут видим, сперва произошла операция инкремента и декримента а потом число 10 начало меняться, и уже измененное число вывелось
--------------------------------------------------------------------------------------------------------------------
const num2 = 20;

switch(num2) {
В условие помещаем обьект того что мы будем сравнивать и что проверять
  case 19: 
  Тут указываем то значение что мы хотим проверить, и здесь есть очень важный момент, конструкция switch всегда идет на строгое сранение(===) в отличие от обычных условий, то есть switch не сравнивает > < , только сравнивает ===
    console.log('Неверно!'); 
    break;
    Всегда после условия нужно писать break, это обязательная синтаксическая конструкция, она работает так, если num2 = 19, то у нас выполнится case 19; и код пойдет дальше, и на break остановится и не пойдет дальше, если break не было бы, код пошел бы дальше прогонять все case что мы прописали
  case 30:
    console.log('Неверно!');
    break;
  case 22:
    console.log('Верно!');
    break;      
  default:
    Если не один из case не сработал, такое может произойти  
    console.log('Не в этот раз(');
    break;
}    

Есть еще и другой синтаксис при помощи тернарного оператора
const num4 = 30;
(num4 === 30) ? console.log('Ok!') : console.log('Error!');     Ok!
(num4 > 60) ? console.log('Ok!') : console.log('Error!');     Error!
И заметь что использовали два оператора это ? и : , такая запись позволяет нам экономить место и обьем кода. Он называется тернарным оператором потомучто в его работе участвует аж 3 аргумента, это единственным тернарный оператор на данный момент который есть в JS
1. (num > 60)
2. console.log('Ok!')
3. console.log('Error!');

Так же есть бинарный оператор, в его работе участвует 2 аргумента
console.log(4 + 4);
+ это бинарный оператор, потомучто он складывает два аргумента
console.log(+'4');
тут + это унарный плюс, так как он использует всего один аргумент для работы, то есть он меняет тип данных string на number
--------------------------------------------------------------------------------------------------------------------
Логический оператор И(&&),он возвращает правду если все аргументы верны
1. Оператор И(&&) всегда возвращает первое ложное значение если оно есть, на нем он запинается и его возвращает и дальше код уже не идет
2. Если все аргументы верны, код дошел до конца, то возвращает значение последнего аргумента

let a = 0;
let b = 5;
let c = 'Nurike';

if (b && a && c) {
  console.log('yes');
} else {
  console.log('no');
}
// no

console.log(a === 0 && b > 2 && typeof(c) === 'number');  // false, так как условие наткнулось на ложь, и нам вернулось ложь
console.log(b && a && c);   // 0, так как 0 это false. Когда логические операторы работают с данными которые не true/false, они будут возвращать сами значения с которыми они работают,

Запомни что результат логических операций это какое-то логическое булиновое значение

В JS есть 5 сущностей которые будут всегда false 0, ''(' ' это не false, так как это не пустая строка, там есть пробел), null, undefined, NaN. А все остальное всегда будет true

Логический оператор ИЛИ(||), принцип работы похож, но здесь мы проверяем на хотябы одно верное значение. Когда опепратор ИЛИ(||) находит правду он перестает работать и возвращает ту правду на которой он остановился. ИЛИ запинается на правде, но когда все не правда, оператор ИЛИ(||) возвращает последнее ложное значение

Например нам нужно сдать 4 отчета от разных людей
let johnReport, alexReport, samReport, mariaRport = 'done';
И только мария пока предоставила отчет, значит один true есть
console.log(johnReport || alexReport || samReport || mariaRport);
done, Оператор ИЛИ(||) вернул нам первую правду, даже если она стоит вконце этого списка

console.log(!0); // true, 0 у нас false, и оператор НЕ меняет на обратное значение, тоесть true
Здесь никаких хитростей нет, просто обратная операция для того чтобы сказать что-то НЕ, НЕ ПРАВДА, НЕ НЕ ПРАВДА

Приоритеты операторов
|| && !== === != == >= > <= < - + 
Приоритетность идет слева на права, то есть + будет всегда выполнятся первее 
--------------------------------------------------------------------------------------------------------------------
Способ 1. While Пока это условие прадиво мы будем делать какие-то действия, while чем то похож на if(условие). Пока есть батарейка на ноутбуке мы можем писать код
let num = 50;

while (num <= 55) { 
  console.log(num);
  И тут можно догодаться, что наше действие будет выполнятся бесконечно, так как уловие правдивое
  num++;
  С помощью инкремента мы каждый цикл увеличиваем num на 1, до тех пор пока условие не будет false
}

Способ 2. do При помощи него мы можем сперва заставить наш цикл что-то сделать, а потом уже проверить условие и если необходимо выйти из цикла
let num2 = 30;
do {  // То есть сделай пожалуйста что-то
  console.log(num2);
  num2++;
}
А потом проверяем условие
while (num2 <= 29);
Смотри хоть и условие не верно, но действие выполнилось один раз

Способ 3. Самый часто используемый 
let num3 = 40;
for (let i = 0; i <= 5; i++) {
  console.log(num3);
  num3++;
}
Тут i просто делает 5 шагов, а действие будет увеличивать наш num3 будет увеличивать 5 раз, так как сказано в условии

Иногда необходимо закончить цикл досрочно, если вдруг переменная приняла какое-то специфическое значение
for (let i = 1; i < 10; i++) {
  if (i === 6) {
    break;  // break полностью прерывает цикл на этом этапе
  }

  console.log(i);
}
То-есть цикл дойдет до 5 сталкнется с break и прекратит работу

А иногда нужно пропустить какую-то итерацию

for (let i = 1; i < 10; i++) {
  if (i === 6) {
    continue;
  }

  console.log(i);
}
Видим что 6-ой итерации нет. Если например хотим избежать каких-то четных значений или каких-то определенных значений в переборе нашего цикла

Вложенность циклов
Например у вас есть цикл который постепенно перебирает данные, когда он натыкается на определенные структуры(например массив), то ему нужно перебрать эти уже данные еще раз, возникает цикл в цикле
for (let i = 0; i < 3; i++) {
  console.log(i);
  for (let j = 0; j < 3; j++) {
    console.log(j);
  
  Чаще всего во вложенных циклах используют букву j
  }
}
Принцип работы цикла в цикле, сперва цикл i выводит 0, потом цикл j выводит 0 1 2. Следующая итерация цикла i, i выводит 1, затем j выводит 0 1 2. Следующая итерация i, i выводит 2, затем j выводит 0 1 2
--------------------------------------------------------------------------------------------------------------------
Переменнве в функции видны только в функции, чтобы вынести переменную из функции ее нужно возвращать(return) или обьявлять глобальную переменную

let num2 = 20;
Так мы обьявили глобальную переменную

function showSecondMessage(text) {
  console.log(text);
  num2 = 30;
  А здесь мы уже ее переиспользовали, и это значит что любая фукнция, она может спокойно брать и использовать глобальную переменную внутри себя
}

showSecondMessage('Hello Nurike!');
console.log(num2);
30, Потомучто мы в функции переназначили переменную

Замыкание функций - это сама функция вместе со всеми внешними переменными которыми ей доступны
let num4 = 20;

function showSecondMessage(text) {
  console.log(text);
  let num4 = 10;
  console.log(num4);  // 10
}
Эта переменная num4 которая внутри функции, когда код доходит до console.log(num4), она сперва начинает искать эту переменную внутри функции, находит и выводит ее

showSecondMessage('Hello Nurike!');
console.log(num4);  // 20

let num5 = 20;

function showSecondMessage(text) {
  console.log(text);
  console.log(num5);  // 20
}
Но если в функции нет переменной num5, функция начинает искать на уровень выше, находит глобальную переменную num5, и выводит уже ее

showSecondMessage('Hello Nurike!');
console.log(num5);    // 20

function calc(a, b) {
  // let plus = a + b;
  // return plus; ИЛИ
  return (a + b);
  Можно и без скобок, скобки для того чтоб просто сгрупировать это значение
}
Когда запустится функция calc она нам вернет сумму первого арнумента и второго, и эта маленькая функция уже решает за нас очень многие проблемы, так как мы ее можем переиспользовать много раз

console.log(calc(5, 6));  // 11
console.log(calc(2, 40)); // 42
И теперь просто переиспользуем эту функцию с разными аргументами, в этом и заключается суть функций, автоматизация наших процессов.

Более сложный пример

function testFunc(a, b) {
  return a + b;
}

function testFunc2(c, d) {
  console.log(testFunc(c, d) + 50);
}

testFunc2(10, 40);   // 100
Тоесть мы вернули значение из первой функции и использовали ее во второй функции

Или еще более локаничный вариант
function testFunc2(result, amount) {
  console.log(result + amount);
}
testFunc2(testFunc(5,5), 10); // 10


function calc(a, b) {
  return (a + b);
  console.log(num2);
  Unreachable, не читаемый код, так как после return, дальше идет мертвый код. return это окончание функции
}

function ret() {
  let num = 20;
  return num;
  То-есть во внешний мир наша функция возвращает значение своей локальной переменной, этот прием в практике очень часто используется, ведь в функции может выполнятся какой-то огромный код, какая-то логика по работе с зарплатами, с какими-то данными и прочим, и вконце нам возвращается результат работы этой функции, и его мы уже можем куда-то записать
}

console.log(ret()); // 20
const anotherNum = ret();
console.log(anotherNum);  // 20

Классификация функций
1) Function Declaration - это по факту обычная функция которую мы уже использовали, и у нее есть одна очень важная особенность, она существует еще до того как наш код запустится, как переменная var.

console.log(testFun('nurike', ' is a great Frontend Developer'));

function testFun(a, b) {
  return a + b;
}
Иногда разработчики такой прием применяют, что все функции которые созданы в одном из файлов, они помещают их в самый низ страницы, а сверху просто используют, ну это уже стилистика у каждого разработчика будет своя

2) Function Expression - функциональное выражение, тут синтаксис немного отличается, мы должны создать переменную и во внутрь положить какую-то функцию
const logger = function() {
  console.log('Hello');
};

logger();
Такая функция создается только тогда, когда до нее доходит поток кода, и ее можно вызвать только после ее обьвления

3) Стрелочная функция, была добавлена в стандарте ES6
const calc2 = (a, b) => a + b; это сокращенный вариант, если функция только в одну строку, то можно опускать фигурные скобки и более того пишем даже без return, и такой способ очень часто будем встречат, более того если один аргумент, можно записать и так
const calc2 = a => a + b;
Понятное дело такой синтаксис очень сильно позволяет сократить код, однако перед тем как ее использовать нужно знать ее особенности. Такая функция не имеет контекста вызова, поэтому ее часто можно встретить в обработчиках события, ну эти темы дальнейших уроков. Пока что помни у нее есть свои особенности и везде прям ее использовать нельзя, хотя очень хотелось бы
const calc2 = (a, b) => {
  console.log('This is function');
  return a + b;
};
А если функция в несколько строк, пишем как обычно

Еще раз про важность аргументов 
Пример с обменикам валют, это такой реальный пример который используется на сайтах обмениках, может быть много разных валют и разных курсов
const usdCurr3 = 28;
const eurCurr = 50;
const rusCurr = 48;

function convert(amount, curr) {
  console.log(curr * amount);
}

convert(500, usdCurr3); // просто как пример, 500 доларов это 14000 тенге
convert(500, eurCurr);  // 500 евро это 25000 тенге
convert(500, rusCurr);  // 500 рублей это 24000 тенге
Теперь мы просто можем вызвать функцию с нужным аргументом, и теперь в эти аргументы можем передавать какой угодно курс валют, какую угодную переменную

А теперь представь что если бы второго аргумента не было, и было бы куча валют
const usdCurr4 = 28;
const eurCurr4 = 50;
const rusCurr4 = 48;

function convertUsd(amount) {
  console.log(usdCurr4 * amount);
}

function convertEur(amount) {
  console.log(eurCurr4 * amount);
}

function convertRus(amount) {
  console.log(rusCurr4 * amount);
}

convertUsd(500);
convertEur(500);
convertRus(500);
Все тоже самое, но смотри сколько функций мы наплодили(грязный код), когда там была всего одна функция для ковертации. Действия ведь одни и теже, даже если бы действия не много отличались, могли бы использовать условия, так что всегда думай, как сделать более короче и красивее. Здесь мы соблюдаем принцип DRU(don't repeat your self) не нужно повторять код там где можно этого не делать, в нашем случае при помощи одной функции избежали всего этого. А вот если создавать десяток отдельных, не универсальных функций, то таким образом вы пишите плохой код и нарушаете этот принцип. И конечно же чем сложнее будет код, тем сложнее будут связи между аргументами и всем прочим

Про важность return

const usdCurr5 = 28;
function convert(amount, curr) {
  console.log(amount + curr);
  Эта функция занимается тем что выдает результат, но она его дальше никуда не передает, этот результат просто выводится в консоль. Нужен ли в коде нам какой-то результат, думаю что нет, потомучто в консоле мы вопелнели основное действие и все, функция выполнила свое главное действие. Но давайте развивать дальше ситуацию, если полученное значение нам понадобится дальше, то как это вообще будет выглядеть, полученная сумма у нас будет уменьшена из-за скидки
}
convert(500, usdCurr5);

const usdCurr6 = 28;
const discount = 0.9;

function convert(amount, curr) {
  return amount * curr;
  Эта функция возвращает конвертированную сумму 
}

function promotion(result) {
  console.log(result * discount);
  Эта функция отвечает за умножение конвертированной суммы на скидку discount
}

promotion(convert(500, usdCurr6));

Интересный момент, мы можем в функцию promotion засунуть в виде аргумента другую функцию. Что здесь происходит, у нас как и раньше запускается функция convert, и она теперь возвращает какой-то результат, то есть какое-то число, причем мы ее вызвали с аргументами и когда она закончит свою работу она возвратит нам результат, этот результат(число) уже в качестве аргумента пойдет в function promotion(result) сюда, и потом с этим результатом уже что-то будет происходить. Конечно далеко не всегда удобно записывать функцию внутри функции, поэтому частенько будем использовать какой-то промежуточный результат
  const res = convert(500, usdCurr6);
  promotion(res);
Самое главное что мы сделали с функцией convert, то что она возвращает какой-то результат, а другая функция promotion уже с ним что-то делает, то есть выводит в консоль. Поэтому когда пишите функцию вы должны представлять что она будет делать и как использоваться. В фунции может быть много каких-то действий расчетов, выводов в консоль и т.д., все это вполне допустимо. Конечно желательно чтоб функция выполняла какое-то одно действие, не смешивать в кучу все подряд, потому-что это будет не удобно и не практично

Стоит так же сказать после ключевого слово return может быть возвращенно любое занчение: просто число, обьект, массив, какая-то другая функция и т.д. это уже более сложные шаблоны с которыми стоит знакомится постепенно. Например в основе приема компонента высшего порядка, лежит то что функция возвращает другую функцию

function anotherFunction() {
  console.log('something');

  return function(){};
}

И запомни что все сложные приемы на самом деле состоят из вот таких базовых вещей

return на самом деле можно вообще использовать и без значений
function test() {
  for (let i = 0; i < 5; i++) {
    console.log(i);
    if (i === 3) return;
    Здесь можно записать и без фигурных скобок, потому что это одно не большое действие, поэтому такой синтаксис тоже допустим, да на него могут ругаться JSHint, но это тоже допустимый вариант. Крч когда итератор дойдет до 3, не только цикл прекратит свою работу но и  вся функция тоже
  }
  console.log('done');
  Для теста специально после return записали что-то для вывода в консоле, и после 3 ничего не видим, функция прекратила свою работу
}
test();
Данный прием действительно полезен когда нужно завершить работу функции

Но в голову может прийти филосовский вопрос, а что вообще тогда возвратит return, он возвратит undefined. На самом деле любая функция что-то возвращает, даже если вы не используете return, но на уровне кода, самого движка JS, функция все равно закончится return undefined 
function promotion(result) {
  console.log(result * discount);
  return undefined; что-то вроде такого, но код это делает внутри, и все делает за нас
}
function doNothing() {} // Пустая функция
console.log(doNothing() === undefined); // true
Это простое докозательство того что функция нам все равно что-то возвращает

Классические функции иногда используются не совсем в очевидных местах и не совсем очевидных конструкциях, в том числе сюда относится callback функция, мы ее очень активно будем применять в дальнейшем

Что такое callback - это функция которая должна быть выполнена после того как другая функция завершила свое выполнение. Если смотреть только на код, все становится не совсем очевидно, потому-что задержка изначально у нас может быть и не видна, то есть мы не знаем как долго будет отрабатываться первая функция, а в коде когда мы так вызываем функции, мы предполагаем что они выполнятся строго одна за другой, и может получится совершенно не предсказуемый результат. Особенно это важно когда эти функции работают с одними и теми же данными. Так что запомни правило, если функции идут одна за другой это не значит что они выполняются прямо так же, да они запускаются одна за другой, но результат могут отдать в разное время

function learnJS(lang, callback) {
  Это и есть главный шаблон callback функции, то что в другую функцию в качестве аргумента в будущем мы сможем передать другую функцию 
  console.log(`Я учу ${lang}`);
  callback();
  Тут выполняем эту callback функцию и ВЫЗЫВАЕМ. Получется так, когда выполнится действие первой функции то есть console.log и только после этого в работу вступит вторая функция
}

learnJS('JavaScript', function() {
  console.log('Уже знаю callback функции');
});
Но так как мы передали анонимную функцию, она потом исчезнет, то есть мы несможем к ней больше обратится, но вполне можно сюда передавать какую-то осознаную функцию

function done() {
  console.log('Уже знаю callback функции');
}

learnJS('JavaScript', done);
И заметь что в аргументе мы не вызываем функцию(не пишим круглые скобки), мы просто туда передали функцию, она выполнется в первой функции callback() это мы именно ее вызываем. Мы ее просто передаем, чтоб она уже в дальнейшем была использована
Callback позволяет быть нам уверенным в том что определенный код не начнет исполнение до того момента, пока другой код не завершит свое исполнение

Передача одного аргумента из функции в другой с помощью callback
function testFunc(a, b, callback) {
  let result = a + b;
  callback(result);
}

function testFunc2(c) {
  console.log(c + 40);
}

testFunc(5, 5, testFunc2);
--------------------------------------------------------------------------------------------------------------------

ОБЬЕКТЫ

Для людей которые знакомы с программированием на других языках, обьекты в JavaScript это так называемые ассоциативные массивы, которые присутствуют в некоторых других языках, например в PHP


И вы должны понимать что существует в языке JS так или иначе идет от обьектов, например когда используем метод toUpperCase на строке, откуда у обычной строки появляется метод который еще и что-то умеет делать, дело в том что строка на базовом уровне тоже является обьектом, и получает этот метод через цепочку прототипов. Что такое прототипы и как это работает разберем дальше. Пока что помни что JAvaScript является обьектно ориентированым языком и все сущности которые в нем есть сводятся к обьектам. Если же вдаваться в терминологию программирования JS правельнее называть прототипно ориентированым языком

МАССИВЫ

<<<<<<< HEAD
console.log(options);
Удалили свойство width, но если нужно удалить сразу несколько обьектов нужно запускать цикл, который будет на какие-то параметры ориентироваться и удалять определенные свойтсва

--------------------------------------------------------------------------------------------------------------------

let a = 5,
    b = a;

b += 5;
// Анологично этой записи b = b + 5

console.log(b); // 10
console.log(a); // 5

const obj = {
  a: 5,
  b: 1
};

const copy = obj;

copy.a = 10;

console.log(copy);  // { a: 10, b: 1 }
console.log(obj);   // { a: 10, b: 1 }
// И получаем вот такую картину, в консоле получаем два обсулютно одинаковых обьекта, хотя мы создали копию const copy = obj;, и уже у копии только поменяли значение, а не сам изначальный обьект. На практике видим что изменяя что-то внутри копии, мы модифицируем наш изначальный обьект. То-есть эта конструкия не сработала const copy = obj; или сработала как-то не правильно

// Обрати на это особое внимание на эту тему, потому-что в будущем могут быть проблемы, если не поймете как это все работает
// Когда мы работаем с какими-то примитивными типами данных(строки, числа, логических значений) то они передаются по значению, проще говоря когда прописываем такую конструкцию let a = 5, b = a; и работая с примитивными типами данных, то b заменяется на 5. А когда работая с какими-то обьектами(обьекты, массивы, функции, какие-то спецефичиские обьекты типа обьект даты) то у нас здесь идет передача уже не по значению а по ссылке, то есть здесь const copy = obj; мы не скопировали новый обьект, мы передали copy ссылку на обьект obj. Это значит что obj она передает не саму структуру обьекта, она передает именно ссылку. И это обозначает, что мы модифицируя копию copy.a = 10; мы как бы модифицируем наш изначальный обьект, потомучто мы работаем не с копией этого обьекта, а именно с сылкой на предыдущую структуру, в нашем случае это обьект. Такое поведение называется передача по ссылке

// Создаем копии таких структур
// Способ 1 с помощью цикла(перебора обьекта)

function copyObj(mainObj) {
  let anotherObj = {};

  let i;  // Можно вынесни переменную
  for (i in mainObj) {
    anotherObj[i] = mainObj[i];
    // В пустой обьект копируем свойтва нового обьекта, то есть по простому, мы пройдемся по старому обьекту скопируем все свойства и поместим их точно так же в новую копию
  }
  return anotherObj;
}


const numbers = {
  a: '555',
  b: 2344,
  c: {
    x: 7,
    y: 4
  }
};

let newNumbers = copyObj(numbers);
console.log(newNumbers);
// Теперь мы совершили именно клонирование обьекта, убедимся в этом

newNumbers.a = 555;
console.log(numbers);
// Видим что в основном обьекте значение в a осталось в строковом типе данных '555'
console.log(newNumbers);
// А копия поменяла занчение в числовой тип данных 555

// Но если такой обьект протестируем более тщательно
newNumbers.c.x = 70;

console.log(newNumbers);
console.log(numbers);
// То заметим значение в свойтве x поменялось в двух местах. Когда мы клонируем обьекты есть два важных понятия, это глубокие и поверхностные копии обьекта. Сейчас мы создали поверхностную копию обьекта, потому что она берет все обычные свойства которые были в родителе и создает как бы независимые структуры, но как только появляется вложенная структура, одно из свойств будет содержать обьект или массив, то это свойство будет иметь опять же ссылочный тип данных. Чуть дальше по курсу научимся создавать и глубокие копии

Метод Object.assign смотри в ШпораМетоды

// Новые стандарты ES6 и ES8
// Оператор разворота. в ES6 стандарте такой оператор появился для массивов, а в ES8 стандарте уже и для обьектов. Этот оператор называется spread оператор(оператор разворота) - он разворачивает структуру и превращает ее просто в набор каких-то данных. Смотри в ШпораМетоды
=======
Пседвомассивы
Мы как фронтендеры, будем сталкиваться с этим понятием очень часто. Когда мы работаем с элементами на странице, то мы как раз и будем получать псевдомассивы, по факту это такой обьект, структура которого совпадает со структурой массива, то есть он будет выглядеть как массив ['bla', 'test], но при одном очень важном условии, у таких псевдомассивов не будет вообще никаких методов! Ни метода forEach, filter, sort, push, pop, join и т.д. Это просто структура которая хранит данные по порядку
>>>>>>> 1bd9ef45f8cb919f048f260edb85214cdef5bfd9
