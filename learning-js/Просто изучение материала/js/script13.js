'use strict';

/* ООП (обьектно ориентированное программирование)
И один из его типов прототипно ориентированное программирование
*/

"This is string";   // Это обычный примитив, протой тип данных
"This is string".toUpperCase(); 
/*
Тут JS оборачивает эту строку в обьект, и после модификаций
возвращает строку на место
*/

let str = "some";
let strObj = new String(str);

/*
Так создали новую строку, но таким способом никто не пользуется
просто для примера
*/

console.log(typeof(str));       // => string
console.log(typeof(strObj));    // => object

/*
Представим легковые автомобили. Это наш прототип. 
И от него отпачковываются разные машины, с одинаковыми свойствами,
но с разными значениями
let car = {
    name: "bmw",
    series: "5series",
    body: "e34",
    year: "1995",
    color: "grey"
}
Так же и в коде, не важно что находится в массиве или какая строка,
методы и свойства (length, slice(), toLowerCase()) остаются теже.
Мы создаем новый экземпляр прототипа массива, строки
*/

console.dir([1,2,3]);
/*
Видим наш массив, мы создали экземпляр массива, но весь прототип array,
который дает нам возможность создавать такие структуры, он находится
в свойстве _proto_. Раскрыв его, видим все методы массива(slice, sort и т.д.).
И в конце видим снова свойство _proto_  который ссылается на обьект,
и тут видим что в JS все состоит из обьектов. Мы будем создавать 
обьекты которые будут прототипно наследоваться друг от друга 
*/

let soldier = {
    health: 400,
    armor: 100,
    sayHello: function() {
        console.log("Hello");
    }
};

// let john = {
//     health: 150
// };

/*
И нам надо чтоб наш джон стал солдатом, и перенял свойства солдата,
но некоторые значение в зависимости от его специфики будут другие 
*/

// john.__proto__ = soldier;

/*
Такой способ устаревший, но может еще встречаться в коде,
но не нужно использовать это свойство в реальных проектах
*/

// console.log(john);

/*
Видим что у джона пока есть только его health
*/

// console.log(john.armor);
// john.sayHello();

/*
=> 100
=> Hello
То есть джон перенял у прототипа его свойство и методы брони 
и умеет говорить.
То есть есть глобальный прототип модального окна,
со своствами (ширины,высоты,цвета)
с методами (при клике на крестик, закрывать мод. окно).
И в дальнейшем можем создавать копии этих модальных окн
со своими значениями, и создавать новые свойсва и методы
*/

// Рабочий способ

// Object.setPrototypeOf(john, soldier);
// console.log(john.armor);
// john.sayHello();

/*
Первый аргумент это тот обьект которому хотим назначить
прототип, а второму аргументу назначаем тот обьект прототип
которого мы устанавливаем. Это если нужно сделать в динамике,
тоесть джон уже существовал, и мы ему установили какойто прототип.
Но обычно работая с кодом, мы не создаем обьект и назначаем
ему прототип, а мы делаем это все на этапе создания обьекта 
*/

let john = Object.create(soldier);
console.log(john.armor);    // => 100
john.sayHello();            // => Hello

/*
ООП это наука о том, как правильно делать архитектуру.
Так же JS можно назвать прототипно ориентируемым языком,
это частны случай ООП (один из его стилей), и как видим
в JS все строится на прототипах 
*/

