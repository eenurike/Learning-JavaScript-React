'use sctrict';

// ОБЬЕКТЫ

const obj = new Object();
/*
Обычно этим способом никогда не пользуются, но просто чтоб знать.
Лучше использовать фигурные скобки
const obj = {

}
*/

const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    },
    makeTest: function() {                  // Наш собственный метод, который будет чтото делать
        console.log("Test method");
    }
};

//delete options.name;        // Оператор удаления
console.log(options);
/*
Видим наш обьект, но без свойства name
*/


for (let key in options) {
    console.log(`Свойсиво ${key}, имеет значение ${options[key]}`);
}
/*
Перебираем каждое свойство обьекта, key это свойство обькта,
но у внутренего обьекта в консоле он выводит [object object].
Дело в том что мы выводим все значения в качестве строк,
и когда цикл доходит до свойства colors, он не может 
обьект превратить в строку, и [object object] это строковое
преставление обьекта 
*/

console.log(options["colors"]["border"]);
/*
Так мы обращаемся во внутренний обьект, к определенному свойству
*/

for (let key in options) {

    if (typeof(options[key]) === "object") {     //Если свойство равно обьекту
        for (let i in options[key]) {       //и внутри этого свойства который обьект запускаем перебор
            console.log(`Свойство ${i} и его значение ${options[key][i]}`);
        } 
    } else {
        console.log(`Свойство ${key} и его значение ${options[key]}`);
    }
}
/*
То есть если свойства обьекта будет равно по типу данных object,
то запускается перебор имено этого обьекта, а конструкция options[key][i]
это мы перебираем первый обьект, находит этот обьект, и перебирает его свойства.
Чуть позже изучим такой способ как рекурсия, будет работать точно так же
только с функциями 
*/


// Методы обьекта

/*
У обьекта нет свойства length, какое кол-во элементов есть в обьекте
*/

// Приём 1. Создать счетчик 

let counter = 0;

for (let bla in options) {
    counter++;
}
console.log(counter);       // Но это не очень удобно


let num = 0;                    // Но если нужно посчитать и внутрение обьекты 
for (let key in options) {

    if (typeof(options[key]) === "object") {     
        for (let i in options[key]) {      
            console.log(`Свойство ${i} и его значение ${options[key][i]}`);
            num++;
        } 
    } else {
        console.log(`Свойство ${key} и его значение ${options[key]}`);
        num++;
    }
}

console.log(num);   
/*
=> 5
Видим что мы подсчитали свойства и во вонутреннем обьекте, если 
надо было подсчитать просто в первом обькте, то записали бы
num++ в условие else, так было бы 4 свойства
*/


// Приём 2. Воспользуемся встроенным методом

console.log(Object.keys(options));
/*
Видим что метод обьекта keys вывел наши свойства обьета в виде массива,
а вот уже у массива есть свойство length
*/

console.log(Object.keys(options)[0]);       // => test

console.log(Object.keys(options).length);       // => 4 

options.makeTest();         // Запускаем наш собственный метод


/*
Обьекты могут сохранять в себе абсолютно все типы данных, в формате ключ значение,
или вложенные обьекты (обьекты в обьекты, массивы в обьекты)
*/


// Деструктуризация обьекта 

/*
Иногда нам нужно достучаться до вложенных свойств
options["colors"]["keys"]
не очень удобно использовать вот такую конструкцию,
и Jshint начал ругаться на эту конструкцию.
Деструктаризация - это как бы мы будем каждое свойство обьекта
выносить за наш обьект в виде переменных, в виде маленьких коробочек, 
и как то в дальйнейшем использовать 
*/ 

let {border, bg} = options.colors;
console.log(border);
/*
Вытащили свойство border и bg и создали переменные с такими же названиями
и вытащили из внутренего обьекта colors.
JavaScript это обьектно-орентированный язык и все сущности которые в нем есть 
сводятся к обьектам  
*/

