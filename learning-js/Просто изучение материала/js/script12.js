'use strict';

// Передача данных по ссылке и по значению 

let a = 5;
let b = a;

b = b + 5;

console.log(b); // => 10
console.log(a); // => 5
/*
Тут видим что значение в переменной "a" осталось изночальное
*/

let obj = {
    a: 5,
    b: 1
};

let copy = obj;     // ССылка
copy.a = 10;

console.log(copy); // => 10
console.log(obj); // => 10
/*
А тут видим что поменяв значение в обьекте copy, мы меняем
значение и родительском обьекте
*/

/*
Когда работаем с примитивными типами данных (строки,числа,boolean и т.д.),
то они передаются по значению.
А когда работаем с обьектами, к ним относятся (массивы, функции, обьект дата и т.д.),
передача идет по ссылке, то есть в переменную copy мы не передали какойто 
новый обьект, мы передали просто ссылку на обьект, и когда модифиципуем
копию, мы модифицируем и изначальный обьект 
*/


// Копирование обьектов. Способ 1

function copyObj(mainObj) {
    let obj = {};

    for (let key in mainObj) {      // С помощью перебора копировали все свойства
        obj[key] = mainObj[key];
    }

    return obj;
}
/*
создали такую общую функцию для копирования обьектов
*/

let numbers = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
};

let newNumbers = copyObj(numbers); 
newNumbers.a = 70;    // Таким образом именно клонировали обьект
console.log(newNumbers);        // => 70
console.log(numbers);       // => 2 Старый обьект не тронут 

newNumbers.c.x = 700;
console.log(numbers);       // => 700
console.log(newNumbers);    // => 700
/*
Когда таким способом клонируем обьекты, есть два важных понятия,
это глубокие и поверхностные копии, когда появляется в одном из 
свойств влоденные структуры такие как (массив и обьект), то
это свойство опять таки будет иметь сылочный тип данных.
Мы будем нормально работать только с поверхностными совйствами
которые лежат в обьекте. Дальше по курсу научимся копировать
и глубокие вложенности 
*/

