'use strict';

// Основы ООП(обьекто ориентированное программирование), и один из стилей прототипно-ориентированное наследование
// Давольно давно программы состояли просто из набора функций, которые вызывали друг друга в нужный момент, здесь довольно много недостатков, и программисты всегда старались усовершенствовать свои техники, так появились: функциональный подход, обьекто ориентированный подход, процедурный и многие другие. JS является обькто ориентированным языком, и главнуб роль в нем играет обьект, он может в себе содержать и методы, свойства, любой тип данных и предстовлять собой целостную структуру, такую некую боевую яденицу. Представим какую ниюудь сущность из реальной жизни, чтоб лучше понимать ООП, например легковой автомобиль, у него есть такие свойства как: двигатель, кузов, колеса и т.д, у него есть такие методы как езда, перевозка грузов и людей и у всех легковых автомобилей так. Смысл ООП в том что мы представляем любую вещь как обьект с набором свойств и методов, точно так же можем представить микроволновку, холодильник и что угодно. 
// Если мы работаем со строкой, у нее есть такое свойство как длина строки и методы для изменения ее региста и т.д, и казалось бы что это целый обьект. Но мы не зря учили типы данных, и когда строка написана просто
'This the text';
// Это обыный примитив, простой тип данных, но как только мы пытаемся вызвать какоето свойство или метод
'This the text'.toUpperCase();
// То JS оборачивает эту строку в обьект и после модификации, возвращает строку на место
let str = 'some';
let strObj = new String(str);
// Таким образом мы можем создать новуб строку, но таким синтаксисом никто не пользуется, но пока мы им воспользуемся
console.log(typeof(str)); // string
console.log(typeof(strObj));  // object, вот примерно так происходит когда мы в JS пытаемся использовать какой-то метод на строке, то есть он оборачивает строку в какой-то обьект, потом использует какой-то метод, который есть у этого обьекта, а потом возвращает все обратно. То есть let str = 'some'; это был примитивный тип данных, а потом new String(str); в работе он превратился в обьект, после этого опять вернулся в примитив. Нужно понять этот механизм, может показаться зачем это нужно знать. В будущем для написания каких-то сложных скриптов, использования библиотек и фреймварков, нам все равно придется с этим работать
// Вернемся к реальному примеру и вспоминаем легковой автомобиль, есть много разных марок автомобилей: bmw, mersedes, audi и т.д, но все это легковушки, именно это понятие и будет прототипом от которого уже можно отпачковывать новые экземпляры, и если посмотреть на всех этих потомков нашего большого прототипа, то и эти значения у всех будут разные: у кого-то будет другой двигатель, другой диаметр, форма кузова, цвет, но самое главное что все эти свойства есть у каждого автомобиля, это и есть приминения обьектно ориентированого программирования и пртотипов в рельной жизни
// Когда мы создаем строки и массивы все они могут содержать обсолютно разные наполнения, но каждый из них обладает разными методами, нам ведь н важно что в строке находится, мы все равно сможем на строке использовать метод toUpperCase(), то есть когда мы создаем например массив, мы создаем экземпляр прототипа массивов
// Посмотрим в браузере
console.dir([1,2,3]);
// И в консоле видим Array(3), раскрываем и понимаем что мы создали какой-то экземпляр массива, но весь собственно прототип который дает нам возможность создавать такие структуры, он находится в свойстве __proto__: Array(0), раскроя его мы можем увидеть все методы которые могут применяться к массивам. И заметь что в конце сново видим прототип который ссылается на обьект __proto__: Object, и убеждаемся что обьект это самая главная структура. И вот те методы которых нет в массиве, но они всеравно откудато берутся у экземпляров массивов, они на самом деле приходят к нам из обьекта например toString() или какие-нибудь другие методы, так что любые конструкции прототипно у нас наследуются от обьекта, и вот по такой цепочке прототипов у нас все работает, в том числе экземпляр: числа, фукции, массива, строки и т.д. В реальных проектах, в реальных программах мы так же будем создавать обьекты, которые будут прототипно наследоваться друг от друга, то есть такая структура описанная выше будет формироваться лично намми, и вы будете часто это делать, особонно в библеотеке React

const soldier = {
  health: 400,
  armor: 100,
  sayHello: function(name) {
    console.log(`Hello, my name is ${name}`);
  }
};
// Это большой прототип который опписывает всех солдат

const john = {
  name: 'John',
  health: 100
};
// Создали отдельного рядового. И сейчас нам необходимо установить связь, чтоб у джона были все свойства что и у солдата, но не которые конечно чтоб были его личными например его здоровье 100
// Старый формат, он все равно может встретиться в коде, но в реальных проектах луччше не использовать

john.__proto__ = soldier;
console.log(john.armor);
john.sayHello(john.name);
// И видим что у джона появилось свойство брони и он может назвать свое имя, хотя изачально мы не прописывали. Эти свойства есть у его прототипа солдата

// Вот такая взаимосвязь очень сильно помогает в реальных проектах, когда мы можем создать один большой прототип например модального окна, которое изначально по умолчанию содержит определенные свойство (высота, ширина, какой-то базовый функционал), и вот от этого прототипа в будущем можем создавать много разных модальных окн, которые будут немного отличаться например по ширине 

// Современные способы создания прототипов

Object.setPrototypeOf(john, soldier);
console.log(john.armor);
john.sayHello(john.name);
// Это если необходимо сделать в динамике, то есть Джон уже существовал, поэтому мы ему установили какой-то прототип, но обычно когда мы работаем с кодом, мы не создаем какие-то левые обьекты, потом им назначаем прототип, мы делаем это все на создании обьекта, мы просто заранее знаем все эти особоенности с прототипами и работаем с ними правильно

const sam = Object.create(soldier);
// Новый обьект Джон, который будет прототипно наследоваться от солдата
console.log(sam.armor);
john.sayHello(sam.name); // Hello, my name is undefined, получаем undefined так как мы создали новый пустой обьект с Сэмом у которого нет своих свойств, и исвойсива с его именем

// ООП это наука о том как делать правельную архетектуру, так же JS можно назвать прототипно ориентированным языком, это частный случай ООП один из его стилей