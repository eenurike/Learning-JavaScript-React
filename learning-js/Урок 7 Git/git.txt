Прежде всегго нужно сказать чтоб git следил за какойто папкой
-> git init (инициируй этот репозиторий)

и увидим в папке как скрытая папка появился .git это и есть наш репозиторий
Затем нужно прописать конфигурации, можно прописать глобально или локально. Глобально значит имя и email будет указан на весь компьютер, а локально конфигурации будут распространяться чисто на конкретную папку
-> git config --local user.name "John"
-> git config --local user.email "example@gmail.com"

Чтоб убедится заходим в папку с проектом и в скрытую папку .git, и видим файл config, заходим туда, и видим что наши данные записались
[user]
	name = John
	email = example@gmail.com

А если нужно глобально
-> git config --global user.name "bla"

Вообще у git репозитория есть три состояния файлов
1. Когда файлы просто созданы - создал index.html и этот файл просто лежит в проекте и ничего с ним не происходит
2. Когда git следит за определенными файлами, когда такое происходит они попадают в так называемый индекс
3. Когда git создал такую определенную точку, в которую вы когда-то сможете вернутся, какие были изменения, как работал проект на данной точке и т.д. оно подругому еще называется commit

Если нужно посмотреть какой статус репозитория
-> git status
Видим что пока нет комитов, и файлы красные, то есть git пока не следит за этими файлами

Чтобы перенести файлы в так называемый индекс
-> git add -A (-A это все файлы, ALL)

Проверим 
-> git status
Тепербь видим что файлы стали зелеными

Теперь добавим новый файл test.css и проверим
-> git status

Видим сразу комбинацию двух состояний, файлы за которыми следит git(зеленым цветом), и файл test.css красным цветом, то что он только что был создан и над ним еще не проводилось еще никаких операций, чтобы заново добавить test.css
-> git add test.css М
ожно опять воспользоваться -A, а можно напрямую написать test.css или *.css, тогда мы возьмем все файлы которые имеют расширение .css

-> git status 
Видим что test.css тоже стал зеленого цвета

Пришло время все эти файлы перевести в третье состояние, в так называемый commit
-> git commit -a -m"first commit"
-a это все файлы
-m это message описание комита, которые мы сейчас делаем
Теперь у нас создана контрольная точка, как будто мы скопировали еще одну папку и теперь можем работать не боясь за то что все старые изменения которые когдато были, которые когда-то понадобятся, они куда-то удалятся

-> git status
Мы ничего не увидим

Изменим что-то в этих файлах
-> git status 
И видим этот измененный файл красного цвета

-> git add -A
-> git commit -a -m"second"
И таким образом можно сохранять все изменения которые произошли в проекте

Чтоб вообще посмотреть какие вообще комиты были, кем были созданы
-> git log

Локально мы научились сохранять точки в нашем git репозитории, а теперь самое важное то что этот репозиторий мы можем выложить в интернет для того чтоб ктото тоже мог с ним работать, ктото мог его скачать, ну и самое важное чтоб наши изменения хранились не только на локальном компе, который может в определеных случаях потерять данные, но и в интернете, то чтоб был так называемый бэкап, для этого есть такой сервис как github. Заходим на этот сервис, регистрируемся если надо, создаем удаленный репозиторий
-> git remote add origin https://github.com/eenurike/fortesting.git
Добавляем удаленный репозиторий, за это отвечает команда remote add, дальше называем этот репозиторий, в данном случае он называется origin и url к этому репозиторию 

Пока ничего не происходит, но теперь наш локальный репозиторий связан с удаленным. И если вдруг мы зохотим отправить с локального компьютера туда в интернет 
-> git branch -M main
Означает что мы будем работать с ветками, и мы нашу главную ветку которая на данный момент называется master переименовываем в main

-> git push -u origin main
Говорим гиту чтоб он запушил(отправил) в наш удаленный репозиторий(origin) в ветку main, -u говорит что все пуши(когда мы берем с локального репозитория данные и отправляем их на удаленный) они будут по умолчанию пушиться именно в origin main. И соответственно последнее слово тоже меняется от master на main

В дальнейшем не нужно польностью прописывать эту команду, можно обойтись лишь
-> git push
Так как мы уже прописали -u origin main

При работе с дома и на работе над одним проектом, например на работе ты запушил новую версию проекта, пришел домой чтоб дальше работать, у тебя дома на компе как бы старая версия проекта и тебя нужно обновиться
-> git pull
Ты как бы тянешь с удаленного репозитория все изменения которые произошли

Частая ошибка начинающих, допустим какойто файл изменил, чтото добавил, но на удаленном репозитории уже ктото внес изменения, и ты пытаешься запушить свои изменения
-> git add -A
-> git commit -a -m"index.html mod"
-> git push
И тут вылазиет ошибка, так как на репозитории произошли изменения, а ты работаешь в старой версии проекта. И в ошибке это и говорится, и советует прописать команду git pull

И теперь наши проекты как бы сливаются(merge). У меня такой ошибки нет, но если такое будет
Lines starting with '#' will be ignored, and an empty message abort the commit.
-> Пишим любой комит
И два раза нажимаем два раза ctrl+s два раза, потом :wq! и нажать enter, это такая хитрость работы с терминалом
Но такая операция  может происходить только при различиях между локальным и удаленным репозиторием, если в самом начале прописать git pull, то таких махинаций не будет

GITIGNORE
Дело в том что когда будем работать в реальных проектах и часть каких то файлов которые лежат внутри проекта у нас на компьютере и которые не хотим пушить на удаленный репозиторий. Чаще всего это рабочие файлы, которые позволяют проекту правильно запускаться либо какието файлы настроек, либо то что не нужно выкладывать в интернет. И самым таким ярким примером является папка node_modules, так как он весит много, и эта папка если будет оправлятся через терминал, это займет много времени


