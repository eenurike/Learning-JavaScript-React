* {
    /* Устанавливаем стандартный шаблон для всех элементов */
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* Прописываем стили для первого section promo */
.promo {
    /* Ширину не прописываем в 1920 потому что, мы просто оставляем ее на воле,
    ведь наш сайт будет подстраиваться под различные размеры экрана, а вот
    высоту установим */
    /* height: 800px; */
    /* Высота бдует строиться по контенту */
    background: url("../img/bg/main_bg.jpg") center center/cover no-repeat;
    /* Сперва нужно выйти из папки!!!
    почему выйти, потому что мы сейчас находимся в style.css, и нужно выйти
    из папки css. Потом можно прям в свойстве background все и прописать
    1) адресс картинки 
    2) позиционирование 
    3) размер
       cover - растягиваем картинку если вдруг она не помещается
       в тот блок где она лежит
    4) не повторялась   
    Поставили слэш(/) без него наша картинка не работает, именно / между
    позиционированием и размером */
}

/* Заметем, что весь контент в макете расположен в контенере, как бы
от контента отступы по бокам, место нечем не занято, разве что фоном,
делается это для того чтобы самы маленькие стандартные мониторы,
отображади правильно наш сайт. Видим в макете что ширина этого контенера
1140px, таким образом человек с монитором 1200px зайдет на этот сайт, у него все будет хорошо отображаться*/

.container {
    width: 1140px;
    margin: 0 auto;
    /* Таким образом блочные элементы ставим по центру */
    padding: 39px 0 62px 0;
    /* Но видим что логотип прижат к верхней границы документа,
    но задать внутрение отступы лучше у родителя сверху и снизу где срелочка */
}

.logo .logo_img {
    /* Так мы прописали наследование, сделали специфичный селектор.
    Нам нужно ценрировать логотип */
    margin: 0 auto;
    /* Ничего не произойдет, так как такой способ работает только с
    блочными элементами, а img у нас строчно блочный элемент */
    display: block;
    /* Если не можешь центрировать элемент, посмотри его блочную модель,
    и если что поменяй его display */
}

.logo .logo_text {
    /* Просто скопировали стили с макета figma */
    color: #fff;
    font-family: Roboto;
    font-style: normal;
    font-weight: 500;
    font-size: 15px;
    /* line-height: 24px; */
    /* Это свойство отвечает за межстрочный интервал,
    высота строки на которой написан этот текст равен 24px,
    но с этим свойством нужно быть осторожным, его лучше 
    использовать если несколько строк текста,
    когда копируешь текст с макета с avacode figma там
    всегда будет у текстов присутствовать это свойство, так как
    когда создается дизайн он сам ставит эти значения */
    text-transform: uppercase;
    text-align: center;
    margin-top: 14px;
}

.title {
    color: #F9BF3B;
    font-family: Roboto;
    font-style: normal;
    font-weight: 900;
    font-size: 41px;
    /* line-height: 41px; */
    text-transform: uppercase;
    text-align: center;
}

h1 {
    margin-top: 53px;
}

h2.title {
    /* Прописали такой специфичный селектор так как, у нас два h2, 
    а отступ нужен только одному, и к title обратиться не можем, 
    так как их тоже два, поэтому сразу без пробела пишем h2.title,
    так как это класс этого же эелемента!!! */
    margin-top: 30px;
}

.simple .title_big {
    color: #fff;
    font-family: Roboto;
    font-style: normal;
    font-weight: 900;
    font-size: 80px;
    /* line-height: 80px; */
    text-transform: uppercase;
    text-align: center;
    margin-top: 21px;
}

.promo .promo_text {
    color: #FFFFFF;
    font-family: "Roboto Light";
    line-height: 28px;
    /* Межстрочный интервал теперь нам нужен, так как у нас
    несколько строк текста. Проще говоря высота строки */
    font-size: 21px;
    font-weight: 300;
    text-align: center;
    padding: 0 13px;
    /* Чтоб было как в макете, когда подключим шрифты все встанет на место */
    margin-top: 23px;
}

.promo .promo_text span {
    font-family: Roboto;
    text-transform: uppercase;
    color: #F9BF3B;
    font-weight: 700;
}

/* Ну и правило для того чтоб было удобнее верстать, не нужно
margin делать в разброс, у одного блока сверху, и другого снизу,
а у этого и сверху и снизу, лучше как то шаблонизировать. 
Например у всех блоков только margin-top или margin-botom.
Так же и с margin-left и margin-right */

.promo .promo_btn {
    /* Тут уже нас интересует ширина и высота, это уже такой более
    оформленный блок */
    /* width: 313px;
    height: 72px; */
    padding: 23px;

    box-shadow: inset 0 0 0 rgba(0, 0, 0, 0.18);
    /* insert это тень падает во внутрь, потом смещение тени по оси X,
    потом смещение по оси Y, затем размытие нашей тени(чем больше значение,
    тем больше размытие), затем цвет(0.18 это прозрачность) */
    border: 4px solid rgba(0, 0, 0, 0.23);
    background-image: linear-gradient(to top, #2798b9 0%, #3ab6da 100%);
    /* Вместо картинки можно установить градиент */
    /* И нужно кнопку поставить в центр, но тег button строчно блочный элемент */
    display: block;
    /* margin-top: 73px; */
    /* Если запишем отступ среху перед нашим центрированием, то ничего не произойдет
    так как margin 0 auto перепишет значение margin top */
    margin: 0 auto;
    margin-top: 73px;

    font-family: "Roboto Condensed";
    font-weight: 400;
    font-size: 21px;
    color: #FFFFFF;
    text-transform: uppercase;
    cursor: pointer;
    /* При наведении появлется обводка кнопки чтоб этого не было */
    outline: none;
}

.more {
    margin-top: 73px;
}

.more .more_text {
    font-family: "Roboto - Thin";
    font-weight: 200;
    font-size: 15px;
    color: #FFFFFF;
    text-transform: uppercase;
    text-align: center;
}

.more .more_img {
    display: block;
    margin: 0 auto;
    margin-top: 13px;
}


/* Наш второй блок */

.waiting {
    background-color: #EFEFEF;
    height: 604px;
    padding: 85px 0 75px 0;
}

.waiting .waiting_header {
    font-family: Roboto;
    font-size: 30px;
    font-weight: 400;
    text-align: center;
    color: #252525;
}

.waiting .waiting_divider {
    width: 217px;
    height: 4px;
    background-color: #f9bf3b;
    margin: 0 auto;
    margin-top: 18px;
}

.waiting .waiting_subheader {
    font-family: Roboto;
    font-size: 23px;
    font-weight: 400;
    text-align: center;
    color: #4a4a4a;
    margin-top: 17px;
}

.waiting .waiting_wrapper {
    margin-top: 45px;
}

.waiting .waiting_wrapper .waiting_item {
    width: 339px;
    /* А вот высоту задавать не будет, всегда нужно
    думать "а если", а если текст будет меняться,
    а мы задали фиксированную высоту, не указав высоту
    высота блока будет автоматически подстраиваться под
    контент внутри */
    text-align: center;

    display: inline-block;
    vertical-align: top;
    /* Потом изучим более новый подход как flex-box */
    margin-right: 48px;
   /* Последний блок сьехал, так как от всех трех блоков
   есть отступ справа, и у последнего блока тоже есть отступ,
   а у нас ведь ширина ограничена, и третьему блоку просто не хватило
   пространство и он сьехал вниз, эту проблему можно решить псевдоселекторами,
   но это дальше */
   margin: 0 15px;
   /* Пока просто примерно задали каждому длоку отступ справа и слева */
}

/* Но нужно себя обезопасить, так как картинки могут быть разного размера,
и верстка вся сьедет */

.waiting .waiting_wrapper .waiting_item .waiting_img {
    /* Чуть позже не будем писать такие большие конструкции */
    width: 100%;
    /* И картинки будут в 100% от родителя, а у родителя waiting_item
    ширина 339px, но ведь высота не поменялась, а если мы пропишем
    и нужную высоту, картинка может сплющится или стать больше,
    то есть она потеряет свои пропорции, и так она будет выглядить
    еще хуже */
}

.waiting .waiting_wrapper .waiting_item .waiting_descr {
    font-family: Roboto;
    font-size: 15px;
    font-weight: 300;
    color: #4a4a4a;
    margin-top: 33px;
}

/* FLEX BOX */

.my-flex-container {
    display: flex;
    /* И видим что наши квадраты встали друг за другом,
    что нужно запомнить что у технологии flex box есть
    две оси: главная(горизонталь) и поперечная(вертикаль) */
    justify-content: center;
    /* Выравниваем наши красные блоки по центру */
    justify-content: space-between;
    /* Элементы распределились по всей ширине родительского блока */
    justify-content: space-around;
    /* Теперь элементы равномерно распределились по ширине родителя */
    align-items: center;
    /* Элементы выровнились по центру по вертикали родителя, так как
    у нас установленна фиксированная высота, если бы высоту не прописали
    то у родительского блока высота была бы по контенту, то есть
    свободного пространства по высоте не было бы, ну и логично,
    что мы бы не могли выравнивать по вертикали, так как свободного
    места по вертикали нет. Прочти статью про flex box к этому уроку */

    /* Нам нужно, если не хватает места в блоке, чтоб часть элементов 
    сместилась ниже */
    flex-wrap: wrap;
    /* Засчет того что у этих красных блоков нет отступов, они
    расположились в строчку сколько им хватало места, а остальные 
    не поместившиеся переместились на следующую ступень */
    height: 450px;
}

.my-flex-block {
    width: 150px;
    height: 150px;
    background-color: red;
    text-align: center;
    color: white;
    margin: 0 50px;
    /* Для красоты установим отступы справа и слева, тогда не имеет
    смысла ставить space-bettwen space-around, так как выравнивание
    идет засчет margin, но justify-content: center конечно оставим.
    Смотри если нет фиксированных отступов то ставь justify-content,
    при адаптивке это очень удобно */
}

/* Но если нужно поменять ось, чтоб элементы стояли не по горизонтали,
а по вертикали */
.my-flex-container {
    flex-direction: column;
    /* Теперь главная ось(вертикальная), а поперечная(горизонтальная)
    и теперь justify-content и align-items работают по другому
    justify-content - отвечает за выравнивание по вертикали
    align-items - отвечает за выравнивание по горизонтали */
}